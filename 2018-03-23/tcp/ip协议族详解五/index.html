<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>TCP/IP协议族详解（五）</title>
        <style>

    html body {
        font-family: 'Mina', sans-serif;
        background-color: #f5f5f5;
    }

    table {
        max-width: 100%;
        margin: 10px 0;
        border-spacing: 0;
        box-shadow: 4px 4px 3px rgba(0,0,0,.125);
    }

    table thead {
      background: #386890;
    }

    table th, td {
        padding: 5px 15px;
        border: 1px solid black;
    }

    table tr:hover {
        background-color: #f1f1A0;
    }

    :root {
        --accent: #386890;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mina">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=VT323">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


<link rel="stylesheet" href="http://shuimu98.gitHub.io/css/main.css">




 


    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/cpp.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/lua.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/shell.min.js"></script>
    

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://gitcdn.github.io/bootstrap-toggle/2.2.2/css/bootstrap-toggle.min.css" rel="stylesheet">
<script src="https://gitcdn.github.io/bootstrap-toggle/2.2.2/js/bootstrap-toggle.min.js"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>


<script>
$(document).ready(function(){
    
  var input = $('#night-mode-toggle');
  var container = $('#bigbody');
  var stat = $('#button-status');
  
  container.toggleClass(localStorage.toggled);
  stat.bootstrapToggle(localStorage.button).change();
  
  input.on('click', function() {
      if (localStorage.toggled != "-nightmode" ) {
          container.toggleClass("-nightmode", true );
          localStorage.toggled = "-nightmode";
          localStorage.button = "on";
       } else {
          container.toggleClass("-nightmode", false );
          localStorage.toggled = "";
          localStorage.button = "off"
       }
  })
});
</script>
 <meta name="generator" content="Hugo 0.45.1" />
        
        

    
    <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/img/favicon/site.webmanifest">
    <link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#000000">
    <link rel="shortcut icon" href="/img/favicon/favicon.ico">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="msapplication-config" content="/img/favicon/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    
    
    
    <meta property="og:title" content="TCP/IP协议族详解（五）">
    <meta property="og:type" content="article">
      
      <meta name="twitter:card" content="summary">
      <meta name="twitter:image" content="http://shuimu98.gitHub.iofavicon/avatar.jpg" >
      
    <meta property="description" content="这个系列的文章主要详细了解TCP/IP协议族，本篇主要介绍TCP传输协议">
    <meta property="og:description" content="这个系列的文章主要详细了解TCP/IP协议族，本篇主要介绍TCP传输协议">
    
    <meta name="twitter:creator" content="">
    <meta name="twitter:site" content="">
    
    </head>

    
    
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    

    <body id = "bigbody">
        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">TCP/IP协议族详解（五）</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/post/">Posts</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                                <li><a href="/links/">Links</a></li>
                            
                                <li><a href="/about/">About</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:shui_mu98@163.com"><i class="fa fa-envelope-o"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/shuimu98/"><i class="fa fa-github"></i></a></li>
                            
                            <li id="night-mode-toggle">
    <input type="checkbox" id = "button-status"
        data-toggle="toggle"
        data-width = "10"
        data-height = "1"
        data-on="<i class='fa fa-moon-o fa-lg' style='vertical-align:25%'></i>"
        data-off= "<i class='fa fa-sun-o fa-lg' style='vertical-align:25%'></i>"
        data-style="ios"
        data-onstyle = "default">
</li>
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div class="item">

    
    
    

    
      
      

    <h4><a href="/2018-03-23/tcp/ip%E5%8D%8F%E8%AE%AE%E6%97%8F%E8%AF%A6%E8%A7%A3%E4%BA%94/">TCP/IP协议族详解（五）</a></h4>
    <h5>2018-03-23 - 2 minutes</h5>

    

    
    <a href="/tags/tcp/ip">
        <kbd class="item-tag"> TCP/IP </kbd>
    </a>
    

</div>


    <br> <div class="text-justify">

<p>本系列文章是<strong>教程：</strong><a href="http://study.163.com/course/courseMain.htm?courseId=1003343002">TCP、IP协议族详解</a>的学习笔记。</p>

<p>该系列大概分为下面几个部分：</p>

<ul>
<li>1、TCP/IP协议4层结构以及每层的作用</li>
<li>2、IP协议详解</li>
<li>3、ARP协议和RARP协议详解</li>
<li>4、ICMP协议详解</li>
<li>5、TCP协议详解</li>
<li>6、UDP协议详解</li>
</ul>

<p>本文主要介绍TCP/IP网络体系中网络层的TCP协议。另外推荐<a href="https://www.cnblogs.com/kzloser/articles/2582957.html">一篇文章</a>，写得很不错。</p>

<p>在介绍TCP协议之前，让我们先了解一下传输层。</p>

<h2 id="1-网络层与传输层关系">1、网络层与传输层关系</h2>

<p>先举一个生活中的例子，假如我在京东上购买了一个物品，发货方为上海的某个商家，收货方就是我的公司地址，比如说是：<code>双击省老铁市666区没毛病软件园A座</code>。但是A座这栋楼很大，快递员不知道我具体在哪一层哪个室，这里就需要一个门牌号，比如说<code>666号</code>。</p>

<p>那么，套路上面的例子，<code>双击省老铁市666区没毛病软件园A座</code>这个地址就类似IP地址，它工作于网络层，它能定位到一块具体的位置，也是就A座这台电脑，在A座这栋楼里面的各个公司就是计算机中的各个进程，每个公司（进程）都占有一个门牌号，这个门牌号就是端口号，<strong>端口号这个概念就属于传输层</strong>。</p>

<p>两台主机间通信条件：</p>

<ol>
<li>本地主机 IP</li>
<li>远程主机 IP</li>
</ol>

<p>两台主机进程间通信条件：</p>

<ol>
<li>本地主机 IP</li>
<li>本地进程 端口</li>
<li>远程主机 IP</li>
<li>远程进程 端口</li>
</ol>

<p>因此，可以简单的理解：网络层（这里指IP协议）提供<strong>主机</strong>之间的逻辑通信，传输层（这里指TCP或者UDP协议）提供提供<strong>进程</strong>之间的逻辑通信。</p>

<h2 id="2-传输层协议详解">2、传输层协议详解</h2>

<h3 id="传输层功能">传输层功能</h3>

<ul>
<li><p>分段及封装应用层送来的数据</p>

<p>例如：我们运送水果，不可能一个一个的运送，一般都是将大堆苹果装车后一车一车的运送，每一车装多少个就是分段数据，装车后要用布封起来保鲜就是封装数据</p></li>

<li><p>提供端到端的传输服务</p>

<p>即源主机端口到目的主机端口进行通信</p></li>

<li><p>在发送主机与接收主机之间构建逻辑通信</p>

<p>如果源主机分别开启Telnet、http访问远程主机的telnet服务和http服务，那么传输层就提供这样一个机制，它构建了两个对应的逻辑通道。</p></li>
</ul>

<h3 id="关于端口">关于端口</h3>

<p><img src="/images/posts/tcp-ip/port.png" alt="端口" /></p>

<p><strong>端口的范围</strong></p>

<p>端口的大小目前是2个byte，也就是说最大有65536个端口，在0~65535这个范围内，我们又把它分成三个部分：</p>

<ul>
<li>熟知端口(著名端口)：0-1023，由ICANN指派和控制（例如：80端口、22端口等）</li>
<li>注册端口：1024-49151,IANA不指派也不控制，但须注册（例如：3306端口，即mysql端口）</li>
<li>动态端口(短暂端口)：49152-65535，IANA不指派也不控制，无须注册，可以分配给你自己的应用</li>
</ul>

<h2 id="3-tcp协议详解">3、TCP协议详解</h2>

<p>核心：TCP协议负责将数据分段成TCP报文段(每一段报文作为传递给IP层的数据)、重组TCP报文段将数据还原。</p>

<h3 id="tcp协议的特点">TCP协议的特点</h3>

<ul>
<li>面向连接：通讯双方交换数据之前必须要先建立连接</li>
<li>可靠性：提供了多种确保可靠性的机制</li>
<li>字节流服务：8bit（1byte）为最小单位构成的字节流（所以不存在粘包的概念）</li>
</ul>

<h3 id="套接字">套接字</h3>

<p>套接字（socket）它是ip地址和端口号的一个组合（例如：192.168.2.172:80），它是TCP连接的最基本的、抽象化的一个对象，也就是TCP连接的端点，一个TCP连接有两个端点。</p>

<p><img src="/images/posts/tcp-ip/socket.png" alt="socket套接字" /></p>

<h3 id="tcp数据传输过程">TCP数据传输过程</h3>

<p>在底层的实现中，TCP发送端和接收端都有对应的缓存，分别是发送缓存、接收缓存，应用层传递给传输层的数据并不一定立即就发送出去了，而是先放入缓存中，然后等待最合适的时机（网络通畅、对端用空闲等等）再把数据发送出去。同理，接收端也是一样的道理。</p>

<p>另外，需要注意，传输层在向IP层传递数据是，是以分组为单位的，而不是按整个字节流来发送，TCP协议把若干字节构成一个分组后，再投递给IP层，这种的分组就称为报文段（Segment），因此，我们常常说TCP报文段就是这样来的。</p>

<p>举例来说：我去菜市场买了一根很长的黄瓜（现在的黄瓜怎么都长那么长- -），太长不好切，那就先把黄瓜切成一段一段的，然后再对每一段切片。这个切成一段的过程就类似TCP数据分段，分段后再交给IP层。</p>

<p><img src="/images/posts/tcp-ip/tcp.png" alt="TCP数据传输" /></p>

<p>让我们在深入一层，拿上图来说，首先我们要知道两个概念：字节号和报文段序号。</p>

<ul>
<li><p>字节号，就是上图中环形缓存中未发送的字节，每个字节所对应的编号（一个格子表示一个字节），字节号的范围是（0~2^32-1），生成方式随机（依赖于系统内核的实现方式）</p>

<p>例如：要发送一个6000byte的数据，并且给第一个字节随机到了一个字节号为1057，那么这6000个字节的数据所对应的字节号就是：1057~7056</p></li>

<li><p>报文段序号，它是基于前面的字节号，其实就是分段后，第一个字节的字节号</p>

<p>例如：把上面的6000字节的数据分为5个报文发送，前4个报文每个发送1000个字节，最后一个发送2000个字节。那么这5个报文段的序号依次是：1057、2056、3056、4056、5056</p></li>
</ul>

<h2 id="4-tcp报文段首部格式">4、TCP报文段首部格式</h2>

<p>它与IP协议首部格式类型，也分为固定部分（20byte）和可选部分。</p>

<p><img src="/images/posts/tcp-ip/tcp-head.png" alt="TCP首部格式" /></p>

<p>和前面一样，通过抓包来逐个解释每个字段。这里访问一个网站，抓包结果如下：
<img src="/images/posts/tcp-ip/tcp-wireshark-1.png" alt="TCP首部抓包结果" /></p>

<p>上面两个结果是一次TCP通讯的往返信息，下面以上图中第三个包作为例子解释各个字段：</p>

<ul>
<li>第1、2个字节：值为dc ea，十进制为56554，表示源端口，一般如果源端没有bind一个端口的话，这个端口将是动态的，比如我们访问一个http网站，第一次访问可能是56554，刷新网页后端口可能就发生了变化。</li>

<li><p>第3、4个字节：值为00 50，十进制为80（也就是大家熟悉的http服务端口），表示目的端口</p>

<p>注意一下这里的<code>Stream index:1</code>，可以看做成一个<strong>五元组</strong>(源IP、源端口、目的IP、目的端口、传输协议)的编号，只要其中一个发送变化，这个流索引号就会发生变化。</p>

<p>另外，这里有个<code>TCP segment Len:0</code>，表示这个报文没有传递数据，因为上图抓的是三次握手的包，所以没有数据长度。</p></li>

<li><p>第5到8个字节：表示报文段序号（图中显示的是相对位置，至于相对位置和绝对段序号是怎么转换的，我暂时也不太清楚，这里留一个疑问）</p></li>

<li><p>第9到12个字节：表示确认号，也是相对序号（三次握手），即告诉对方<strong>我期望收到你的下一个报文段的序号值</strong>。</p>

<p>比如发送的报文段A的序号是100，那么对端收到后确认，并要求你下一个发送的报文段的序号要为100+1=101，这个101就在对端返回的报文段B中的确认号部分。同理，发送端对接收端的数据也要做确认。</p>

<p><strong>流程</strong>如下：</p>

<pre><code>发送端 ----         报文A(序号100)          ---&gt; 接收端
发送端 &lt;---     报文B(序号200,确认号101)     ---- 接收端
发送端 ----下一个数据报文段(序号101,确认号201) ---&gt; 接收端
</code></pre></li>

<li><p>第13、14个字节：这里需要特殊处理一下</p>

<ul>
<li>前4bit表示首部长度，和IP首部一样，也是以4字节为单位（所以tcp头部最大为15*4=60byte）；</li>
<li>后12个bit中，只用到后面6bit，前面的保留（不过现在也有用到前面的bit位了），关于后6个bit每位表达的意义，后面做详细介绍</li>
</ul></li>

<li><p>第15、16个字节:表示窗口大小，最大是65536个字节，也就是64kb。</p>

<p>注意：这个值很重要，下面会有窗口机制的详细介绍。</p></li>

<li><p>第17、18个字节：校验和，它校验的范围包括tcp首部和数据两个部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部（伪首部就是ip地址）。</p></li>

<li><p>第19、20个字节：紧急指针，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。同时 URG比特位要置1。</p></li>

<li><p>可选选项：主要介绍MSS（maximum Segment Size）,它用来限定TCP报文段数据部分的最大长度，不包含TCP首部。</p>

<p>这里要只要MTU（ Maximum Transmit Unit）这个概念，即最大传输单元，是物理接口（数据链路层）提供给其上层（IP层）最大一次能传输的数据大小，以以太网为例，缺省MTU=1500byte，这是以太网接口对IP层的约束。</p>

<p>例如：IP层有&lt;=1500byte的字节要发送，则只需要一个IP包就可以发送了，如果&gt;1500byte，就需要IP层分片，每个分片有相同的IP首部。</p>

<p>一般情况下，有<strong>以下等式</strong>：
MSS = MTU-TCP首部（20byte）-IP首部（byte）</p></li>
</ul>

<p><strong>6bits 每个比特位介绍</strong>：</p>

<ul>
<li>紧急比特 URG： 当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li>
<li>确认比特 ACK： 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效</li>
<li>推送比特 PSH (Push): 接收 TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>
<li>复位比特 RST (Reset)： 当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接</li>
<li>同步比特 SYN: 同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文，一般是tcp建立连接的第一个tcp报文。</li>
<li>终止比特 FIN (Final)： 用来释放一个连接。当FIN = 1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。一般是tcp终止连接的最后一个报文。</li>
</ul>

<h2 id="5-tcp三次握手">5、TCP三次握手</h2>

<p>tcp使用三次握手机制建立TCP连接，三次握手流程如下：
<img src="/images/posts/tcp-ip/tcp-shake-hands.png" alt="TCP三次握手" /></p>

<p>下面详解讲解这三个过程：</p>

<ul>
<li><p>连接发起方首先发送一个 SYN，SEQ=X（这个报文的序号是系统随机的）</p>

<p>发送的报文A: SYN，SEQ=X（假如X=1000）</p></li>

<li><p>接收方收到SYN后，会确认这个SYN，并返回SYN+ACK，它确认发送方的SYN，同时也会向发送方也发送一个SYN确认请求，而且还会告知对方，我的窗口大小（可以理解成能接受数据的缓存的大小）</p>

<p>返回的报文B：SEQ=Y(假如Y=5000)，SYN，ACK=X+1（也就是报文A的SEQ+1 = 1001）</p></li>

<li><p>发起方收到接受方的SYN+ACK后，也会对对方的SYN确认，同时也会告知我的窗口大小</p>

<p>返回的报文C：SEQ=1001，ACK=Y+1(也就是报文B的SEQ+1=5001)</p></li>
</ul>

<p>三次握手就是一个“礼尚往来”的过程。比如说：小明有2个苹果，小红有2个梨子，他俩都想要吃对方的水果，那么用三次握手解释如下：</p>

<ul>
<li>小明给了小红一个苹果，用来搭讪，小明：“给你一个苹果，可好吃了”（SEQ=苹果1）</li>
<li>小红吃了一个苹果后，觉得很好吃，于是给了小明一个梨子作为回礼，但是小红还想继续吃，就撒娇说：“人家还想吃苹果”（SEQ=梨子1，ACK=苹果2）</li>
<li>小明一听，哟，有戏啊，于是就把最后的一个苹果给了小红，同时又跟小红说：“要不你把最后那个梨子也给我吧”（SEQ=苹果2，ACK=梨子2）</li>
</ul>

<p>于是小明和小红就勾搭上了，从此性福快乐的在一起了。</p>

<h2 id="6-tcp四次挥手">6、TCP四次挥手</h2>

<p>tcp使用四次挥手机制终止TCP连接，四次挥手流程如下：
<img src="/images/posts/tcp-ip/tcp-bye-hands.png" alt="TCP四次挥手" /></p>

<p>下面详解讲解这四个过程：</p>

<ul>
<li><p>客户方起方首先发送一个FIN，SEQ=X（这个报文的序号是系统随机的）</p>

<p>发送的报文A: SYN，SEQ=X（假如X=1000）</p></li>

<li><p>服务方收到FIN后，会确认这个FIN，并返回ACK，但是这里并没有立即返回FIN给客户方，此时，只能说客户方到服务方的连接释放了，这个TCP连接处于“半关闭”状态，服务方还是能否传送数据到客户方，反之不行。</p>

<p>返回的报文B：SEQ=Y(假如Y=5000)，ACK，ACK=X+1（也就是报文A的SEQ+1 = 1001）</p></li>

<li><p>一段时间后，服务方才发送FIN给客户方，通知客户方，我也要终止连接了</p>

<p>发送的报文C：SEQ=Z(假如Z=7000)，FIN，ACK，ACK=X+1(也就是报文A的SEQ+1=1001)</p></li>

<li><p>最后，客户端确认服务方发送过来的FIN，此时，这个TCP连接就完全终止了。</p>

<p>返回的报文D：ACK，SEQ=X+1(1001)，ACK=Z+1（7001）</p></li>
</ul>

<p>还是上面的例子，小红和小明勾搭一段时间后，小明要分手，分手前决定把之前交换的水果都还回去。</p>

<ul>
<li>小明（客户方）还了一个梨子给小红，并且提出了分手(SEQ=梨子1)</li>
<li>小红答应了，也还了一个苹果给小明，并且要求把最后的梨子也换回来(SEQ=苹果1,ACK=梨子2)</li>
<li>小明在之前吃了一个梨子，发现没有梨子了，就假装没反应，心里寻思着去哪里弄个梨回来，这时候小红又发来通告，“赶紧还我例子，还了赶紧分手”(SEQ=苹果1,ACK=梨子2,FIN)</li>
<li>小明最终搞到一个梨子，并还给了小红，同时要求小红还最后的苹果(SEQ=梨子2,ACK=苹果2)</li>
</ul>

<p>从此，两个就分道扬镳了。</p>

<h2 id="7-tcp确认和窗口机制">7、TCP确认和窗口机制</h2>

<h3 id="确认机制">确认机制</h3>

<p>假如要发送一批TCP报文，每个报文的SN（Sequence number）分别为：1，235，790,1500，当发送790这个报文的时候，对方通过校验和检测，发现数据错误，就会返回一个带ACK的报文，且ACK id = 790，要求发送方重新发送一次790，这就是TCP重传确认机制。</p>

<p>TCP的报文到达确认（ACK），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号（Ack Number）（<strong>注意：这里一定要理解好ACK以及ACK number的意义</strong>）。例如，主机A发送的当前数据序号是400，数据长度是100，则接收端收到后会返回一个确认号是501的确认号给主机A。</p>

<p>举一个例子：</p>

<p>加入要发送1000字节的数据，tcp分片后假设有5个分片，分别是：</p>

<ul>
<li>第1个分片：1-200，共200字节</li>
<li>第2个分片：201-400，共200字节</li>
<li>第3个分片：401-700，共300字节</li>
<li>第4个分片：701-900，共200字节</li>
<li>第5个分片：901-1000，共100字节</li>
</ul>

<p>当发送方发送了1、2、3个分片后，接收方确实时，发现第2个包出现错误，就会返回一个ack包（ack number=2），发送方收到这个ack包后，对比它自己的最高序列号，发现2小于3，就认为是第2个分片错误，需要重传，然后发送方就会重传第2个分片。</p>

<p>TCP提供的确认机制，可以在通信过程中可以不对每一个TCP数据包发出单独的确认包（<strong>Delayed ACK机制</strong>），而是在传送数据时，顺便把确认信息传出，这样可以大大提高网络的利用率和传输效率。</p>

<p>同时，TCP的确认机制，也可以一次确认多个数据报，例如，接收方收到了201，401，701的数据报，则只需要对701的数据包进行确认即可，对701的数据包的确认也意味着701之前的所有数据包都已经确认，这样也可以提高系统的效率。</p>

<h3 id="窗口机制">窗口机制</h3>

<p>tcp利用窗口大小进行流量控制，一般情况下，它是由数据接收端定义的。它用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</p>

<p>来<strong>举一个例子</strong>：有个水池，水池有进水口和出水口，进水的管子根据粗细分为很多根，通过水池现在的空闲大小，我们要动态计算需要用哪种粗细的管子来加水。如果水池现在没水了，就要用更粗一点的管子，同时供水方就加大供水，如果水池快满了，就要切换成细一点的管子，并通知供水方减小供水。</p>

<p>那么上面的水池就是tcp缓存，粗细不同的管子就是就类似是窗口大小，通过窗口大小来达到流量控制的目的。</p>

<p>其实TCP在整个发送过程中，也在度量当前的网络状态，目的是为了维持一个健康稳定的发送过程，比如拥塞控制。因此，数据是在某些机制的控制下进行传输的，就是窗口机制。发送端的发送窗口是基于接收端的接收窗口来计算的。</p>

<p>下图可以生动描述窗口机制的工作原理：
<img src="/images/posts/tcp-ip/tcp-window.png" alt="TCP窗口机制" /></p>

<p>我们把上面的数据分为四种类型：
1. 已经发送且对端已经确认
2. 已发送，对端等待确认（此时还在窗口内）
3. 在窗口内，但未发送
4. 在窗口外，未发送</p>

<p>TCP窗口就是这样逐渐滑动，发送新的数据，滑动的依据就是发送数据已经收到ACK，确认对端收到，才能继续窗口滑动发送新的数据。可以看到窗口大小对于吞吐量有着重要影响，同时ACK响应与系统延时又密切相关。</p>

<p>需要说明的是：如果发送端的窗口过大会引起接收端关闭窗口，处理不过来。反之，如果窗口设置较小，结果就是不能充分利用带宽，所以仔细调节窗口对于适应不同延迟和带宽要求的系统很重要。</p>

<p>关于TCP的窗口机制，可以参考博客<a href="http://blog.sina.com.cn/s/blog_c5c2d6690102wpxl.html">TCP 协议中的 Window Size与吞吐量</a>。</p>
</div>

    

    <hr>
    <div class="text-justify">
    
        <div id="comments-gitment"></div>
            <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
            <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
            <script type="text/javascript">
            const gitment = new Gitment({
              id: '2018-03-23 00:00:00 \x2b0000 UTC',
              title: 'TCP\/IP协议族详解（五）',
              link: decodeURI(location.href),
              desc: '本系列文章是教程：TCP、IP协议族详解的学习笔记。\n该系列大概分为下面几个部分：\n 1、TCP\/IP协议4层结构以及每层的作用 2、IP协议详解 3、ARP协议和RARP协议详解 4、ICMP协议详解 5、TCP协议详解 6、UDP协议详解  本文主要介绍TCP\/IP网络体系中网络层的TCP协议。另外推荐一篇文章，写得很不错。\n在介绍TCP协议之前，让我们先了解一下传输层。\n1、网络层与传输层关系 先举一个生活中的例子，假如我在京东上购买了一个物品，发货方为上海的某个商家，收货方就是我的公司地址，比如说是：双击省老铁市666区没毛病软件园A座。但是A座这栋楼很大，快递员不知道我具体在哪一层哪个室，这里就需要一个门牌号，比如说666号。\n那么，套路上面的例子，双击省老铁市666区没毛病软件园A座这个地址就类似IP地址，它工作于网络层，它能定位到一块具体的位置，也是就A座这台电脑，在A座这栋楼里面的各个公司就是计算机中的各个进程，每个公司（进程）都占有一个门牌号，这个门牌号就是端口号，端口号这个概念就属于传输层。\n两台主机间通信条件：\n 本地主机 IP 远程主机 IP  两台主机进程间通信条件：\n 本地主机 IP 本地进程 端口 远程主机 IP 远程进程 端口  因此，可以简单的理解：网络层（这里指IP协议）提供主机之间的逻辑通信，传输层（这里指TCP或者UDP协议）提供提供进程之间的逻辑通信。\n2、传输层协议详解 传输层功能  分段及封装应用层送来的数据\n例如：我们运送水果，不可能一个一个的运送，一般都是将大堆苹果装车后一车一车的运送，每一车装多少个就是分段数据，装车后要用布封起来保鲜就是封装数据\n 提供端到端的传输服务\n即源主机端口到目的主机端口进行通信\n 在发送主机与接收主机之间构建逻辑通信\n如果源主机分别开启Telnet、http访问远程主机的telnet服务和http服务，那么传输层就提供这样一个机制，它构建了两个对应的逻辑通道。\n  关于端口 端口的范围\n端口的大小目前是2个byte，也就是说最大有65536个端口，在0~65535这个范围内，我们又把它分成三个部分：\n 熟知端口(著名端口)：0-1023，由ICANN指派和控制（例如：80端口、22端口等） 注册端口：1024-49151,IANA不指派也不控制，但须注册（例如：3306端口，即mysql端口） 动态端口(短暂端口)：49152-65535，IANA不指派也不控制，无须注册，可以分配给你自己的应用  3、TCP协议详解 核心：TCP协议负责将数据分段成TCP报文段(每一段报文作为传递给IP层的数据)、重组TCP报文段将数据还原。\nTCP协议的特点  面向连接：通讯双方交换数据之前必须要先建立连接 可靠性：提供了多种确保可靠性的机制 字节流服务：8bit（1byte）为最小单位构成的字节流（所以不存在粘包的概念）  套接字 套接字（socket）它是ip地址和端口号的一个组合（例如：192.168.2.172:80），它是TCP连接的最基本的、抽象化的一个对象，也就是TCP连接的端点，一个TCP连接有两个端点。\nTCP数据传输过程 在底层的实现中，TCP发送端和接收端都有对应的缓存，分别是发送缓存、接收缓存，应用层传递给传输层的数据并不一定立即就发送出去了，而是先放入缓存中，然后等待最合适的时机（网络通畅、对端用空闲等等）再把数据发送出去。同理，接收端也是一样的道理。\n另外，需要注意，传输层在向IP层传递数据是，是以分组为单位的，而不是按整个字节流来发送，TCP协议把若干字节构成一个分组后，再投递给IP层，这种的分组就称为报文段（Segment），因此，我们常常说TCP报文段就是这样来的。\n举例来说：我去菜市场买了一根很长的黄瓜（现在的黄瓜怎么都长那么长- -），太长不好切，那就先把黄瓜切成一段一段的，然后再对每一段切片。这个切成一段的过程就类似TCP数据分段，分段后再交给IP层。',
              owner: 'shuimu98',
              repo: 'shuimu98.github.io',
              oauth: {
                client_id: 'af5065a1372570c7babc',
                client_secret: '3bd955012d21847887f0d3d4f9ea3c2cbc2b7e10'
              }
            })
            gitment.render('comments-gitment')
            </script>
    
    </div>

</main>

        <footer id = "bigfooter">
            <div style = "padding:15px;">
                <p>Powered by <a href="https://gohugo.io">Hugo</a>. Themed by <a href="https://github.com/nathancday/min_night">min_night</a>.
                </p>
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/"
                title="Creative Commons Attribution 4.0 International license">
                <i class="fa fa-creative-commons" aria-hidden="true"></i> Attribution 4.0 International license
                </a>
            </div>
        </footer>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id="></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());
          gtag('config', '');
        </script>
       
    </body>

</html>

