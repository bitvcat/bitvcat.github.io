<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Domi●Cat</title>
    <link>http://shuimu98.gitHub.io/tags/golang/</link>
    <description>Recent content in Golang on Domi●Cat</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 27 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://shuimu98.gitHub.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>读书笔记 ——《Go语言圣经》</title>
      <link>http://shuimu98.gitHub.io/2018-01-27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/</link>
      <pubDate>Sat, 27 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2018-01-27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/</guid>
      <description>本书中文版，点这里。
接触golang也有两三年了，一直没有系统把它过一遍，正好通过这本书系统性的复习一次，掌握golang的细节。
第1章：入门  命令行参数
os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。os.Args的第一个元素，os.Args[0], 是命令本身的名字（例如：D:\Github\xlsxconv\xlsxconv.exe）。
 bufio包，它使处理输入和输出方便又高效。Scanner类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。它是按流模式读取输入，并根据需要拆分成多个行。理论上，可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们，需要使用ReadFile（来自于io/ioutil）和strings.Split。
input := bufio.NewScanner(os.Stdin) for input.Scan() { // TODO ... }  Printf格式字符串：
   占位符 备注     %d 十进制整数   %x, %o, %b 十六进制，八进制，二进制整数。   %f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00   %t 布尔：true或false   %c 字符（rune） (Unicode码点)   %s 字符串   %q 带双引号的字符串&amp;rdquo;abc&amp;rdquo;或带单引号的字符&amp;rsquo;c&amp;rsquo;   %v 变量的自然形式（natural format）,如果包含的#副词%#v，它表示用和Go语言类似的语法打印值   %T 变量的类型   %% 字面上的百分号标志（无操作数）    {: rules=&amp;ldquo;all&amp;rdquo; frame=&amp;ldquo;border&amp;rdquo;}</description>
    </item>
    
    <item>
      <title>每日笔记 —— golang篇</title>
      <link>http://shuimu98.gitHub.io/2018-01-25/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--golang%E7%AF%87/</link>
      <pubDate>Thu, 25 Jan 2018 15:15:15 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2018-01-25/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--golang%E7%AF%87/</guid>
      <description>目录
 TOC {:toc}  go编译  使用go build编译go文件时，go文件必须放在最后，不然会有named files must be .go files的报错。
例如：go build -ldflags &amp;quot;-w&amp;quot; -o ./xlsx2lua.exe ./xlsx2lua.go
 减小golang编译的二进制文件大小：go build -ldflags &amp;quot;-s -w&amp;quot;，如果想进一步减小，可以使用upx对编译的二进制加壳压缩。
 s去掉符号表（然后panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果） w去掉DWARF调试信息，得到的程序就不能用gdb调试了。  golang发布闭源的.a文件（静态库），参考官方文档 Binary-Only Packages。
  package 别名 import xxx &amp;ldquo;fmt&amp;rdquo; 表示xxx是系统包“fmt”的一个别名，在代码中可以使用 xxx.Println 来调用函数。 &amp;gt;注意，当用一个点 “.”来作为一个包的别名时，表示省略调用，在调用时可以不用写包名，类似c++ 中 using namespace std，以后就不用写std::method这样的格式，但是不推荐。
go可见性规则 首字母大写表示public，小写表示private（注意：作用域是packge，即：在同一个包下，大小写都是可以访问的）。
数组、切片（slice）、map  数组和切片的区别和联系
数组：数组的容量和长度是一样的。cap() 函数和 len() 函数均输出数组的容量（即长度）。 切片：切片是长度可变、容量固定的相同的元素序列。Go语言的切片本质是一个数组。容量固定是因为数组的长度是固定的，切片的容量即隐藏数组的长度。长度可变指的是在数组长度的范围内可变。
 golang map的key：只有function、map和slice三个kind不能作为map的key，struct能不能作为key，要看结构体中的字段是否存在前面所提到的三个类型，如果没有则可以作为key。
 Go语言中的Array、Slice、Map和Set使用详解。
append函数返回值必须有变量接收，因为append操作可能会导致原来的slice底层内存发生改变。
 golang map数据结构不能并发读写问题，最新版本的golang 1.</description>
    </item>
    
    <item>
      <title>golang：interface 和 nil 以及 error nil</title>
      <link>http://shuimu98.gitHub.io/2015-03-14/golanginterface-%E5%92%8C-nil-%E4%BB%A5%E5%8F%8A-error-nil/</link>
      <pubDate>Sat, 14 Mar 2015 15:16:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2015-03-14/golanginterface-%E5%92%8C-nil-%E4%BB%A5%E5%8F%8A-error-nil/</guid>
      <description>interface（接口） 在golang中，万物皆interface{}，所以golang中可以将任意类型赋值给interface{}，包括nil也可以赋值给interface{}，interface{}有点像c艹中的纯虚基类，只包含了方法的集合。
interface在底层的实现包括两个成员：类型（_type）和值(data)，我对lua比较熟，这点上类似lua的值在底层的实现，所以比较容易理解（我估计大部分动态语言都是这么干的吧）。_type表示存储变量的动态类型，也就是这个值真正是什么类型的。int？bool？…… data存储变量的真实值。
例如： var value interface{} = int32(100)
那么value在底层的结构就是：{_type:int32,data=100}
关于普通类型与interface{}的转换：
1、普通类型转换到interface{}是隐式转换；例如 fmt.Println(),我们可以传入任意类型的值，Println都会把传入的值转换成interface{}类型
2、interface{}转换成普通类型需要显式转换；
关于接口的实现：
假如有一个接口 type interface{} T, *T包含了定义在T和*T上的所有方法，而T只包含定义在T上的方法。
nil值 在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量。如果未遵循这个规则，则会引发panic。
如何判断一个interface{} 是否是 nil？
根据上面对interface{}的介绍，判断interface{}是否为nil的规则：
&amp;gt;只有在内部值和类型都未设置时(nil, nil)，一个接口的值才为 nil。特别是，一个 nil 接口将总是拥有一个 nil 类型。若我们在一个接口值中存储一个 int 类型的指针，则内部类型将为 int，无论该指针的值是什么：(*int, nil)。 因此，这样的接口值会是非 nil 的，即使在该指针的内部为 nil。
那么思考如下问题：
type T struct{ Age int Name string } func main(){ t1:= &amp;amp;T{20,&amp;quot;kaka&amp;quot;} fmt.Printf(&amp;quot;%p\n&amp;quot;, t1) fmt.Println(t1==nil) //fmt.Println(*t1 == nil) //cannot convert nil to type test }  为什么注释的那行会报错？我的分析是：</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>http://shuimu98.gitHub.io/2014-09-28/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2014-09-28/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>http://shuimu98.gitHub.io/2014-04-02/hugo-template-primer/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2014-04-02/hugo-template-primer/</guid>
      <description>Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.
This document is a brief primer on using go templates.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>http://shuimu98.gitHub.io/2014-04-02/getting-started-with-hugo/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2014-04-02/getting-started-with-hugo/</guid>
      <description>Step 1. Install Hugo Goto hugo releases and download the appropriate version for your os and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at installing hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
    <item>
      <title>Migrate from Jekyll</title>
      <link>http://shuimu98.gitHub.io/2014-03-10/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2014-03-10/migrate-from-jekyll/</guid>
      <description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
  </channel>
</rss>