<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Domi●Cat</title>
    <link>http://shuimu98.gitHub.io/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Domi●Cat</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 08 Apr 2016 23:33:00 +0000</lastBuildDate>
    
	<atom:link href="http://shuimu98.gitHub.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>时间轮定时器</title>
      <link>http://shuimu98.gitHub.io/2016-04-08/%E6%97%B6%E9%97%B4%E8%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Fri, 08 Apr 2016 23:33:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2016-04-08/%E6%97%B6%E9%97%B4%E8%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>定时器实现一般常见的有两种方式：
 时间轮（time_wheel） 最小堆  就我自己的了解，使用时间轮的开源项目有：云风的skynet、陈硕的muduo；而经典的libevent库则使用的是最小堆。
分别解释下最小堆和时间轮的简单概念：
 最小堆：最小堆是一个经过排序的完全二叉树,除开根节点，其他任意节点的值都要小于它两个左右孩子的值。  另外关于二叉树的分类，我会另外单独写个笔记整理一下。
 关于完全二叉树，一个n层的二叉树，除了第n-1层是满的（没有空位），第n层右边可以满可以不满，但是从左到右不能出现空位。可使用广度遍历来判断是否是完全二叉树。
  时间轮：可以直接拿我们生活中的手边做例子，手表一共有三个分级，时钟、分针和秒针，我们把秒针的一个刻度称为一个tick，秒针每走一圈，分针就移动一个刻度， 时间轮的原理就跟手表的模型是一样的。  时间轮算法 时间轮 (Timing-Wheel) 算法类似于一以恒定速度旋转的左轮手枪，枪的撞针则撞击枪膛，如果枪膛中有子弹，则会被击发。下面我将由简入深介绍基于时间轮实现的定时器。
时间轮算法的复杂程度跟你的分级层数有关，最简单的就是只有一轮，复杂一点的就是分层的时间轮，比如Hierarchy 时间轮（也就是linux系统下的时间轮实现方式）。
不分层的时间轮 不分层的时间轮是最简单，也是很容易理解的时间轮模型了：
 假设有个N个槽（tick)的轮子，随着时间推进，每走一个tick的时间，指针指向到槽也往前推进一格，直到一个轮所有的槽都执行完毕。
 下图描述了一个不分层的时间时间轮模型：
我们可以根据上面的模型，实现一个简单实用的时间轮定时器，一般的场景一层的时间轮已经够用了，比如游戏服务器，很少用到时间跨度非常大的定时器。 根据我自己的项目经验，目前我们的游戏服务器内部采用的就是简单的不分层时间轮，模型如下：
	|-- user_t[0] |-slot_t[0]	---	|-- …… |-slot_t[1]	|-- user_t[n] tw.slots = |-…… |-…… |-slot_t[6400-1] tw.lslot = 留一个槽，存放那些超时时间大于一轮的超时事件  上面模型中，slots表示时间轮的槽位，每个槽位里面可能有多个定时器任务，用一个链表来存放这些定时器任务。
该时间轮一共有6400个刻度，一个tick为10毫秒，那么每次走完一个转盘需要的时间等于 6400 * 10ms,即64s，差不多一分钟的时间走一轮。
用lua表述下这个模型，大概如下：
tick = 10 ms -- tick slotlen = 6000 -- 刻度数量 --下面用lua的table表示这个时间轮的数据结构： time_wheel = { slots = { [1] = {timeobj1,timeobj2,…} -- 刻度1上的定时对象 [2] = {timeobj1,timeobj2,…} -- 刻度2上的定时对象 }, lslot = {t1,t2,…} -- 这里存放的是tick超过一圈的定时对象 curTick = 0, -- 当前走了多少个tick } timeObj = { tick=10, -- 表示这个定时对象需要10个tick， tickout = 1230, -- 表示超时的tick，即当定时器tick了1230次后，就触发超时事件 }   ps：</description>
    </item>
    
    <item>
      <title>常见的排序算法解析</title>
      <link>http://shuimu98.gitHub.io/2016-04-08/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 08 Apr 2016 23:35:00 +0800</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2016-04-08/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</guid>
      <description>关于排序算法，从大学到工作，一直都在接触，奈何老是学了忘，忘了学。很是蛋疼，索性就把我自己看过的几个排序算法做个笔记，加深一下记忆。
比较常用的排序算法：
 冒泡排序 （面试常用 - -!） 快速排序 直接选择排序 红黑树排序  冒泡排序 这个排序算法，是比较基础的算法，该算法的核心在我自己的理解是： 两两交换。 只要记住这个算法就是依次比较相邻的两个元素的大小。
假如要参与排序的元素个数为 n，那么需要排序的轮数为 n - 1。而在具体的每一轮 的排序中，只用排序上一轮剩下的。这里有一个可以优化的细节，在每一轮开始循环 比较大小的时候，给一个标示位，如果这一轮排序结束后，该标示位没有变化，说明 已经是有序的了，后面的轮数也可以跳过了。但是最坏的情况还是需要排玩 n -1 轮。
具体的实现我用go实现了一遍，很简单，代码在这里 升序和降序只需要改下比较大小的顺序就OK了，很容易实现。
快速排序 该算法的效率很高，所以敢称快速排序。它的思想是基于二分法。算法思想：从无序的 元素中选取一个基准元素，一般都选第一个元素，然后用这个基准与其他元素对比，大的 放一边（这一堆元素暂时是无序的，暂且称为大子队列），小的放另外一边（也是无序的，暂且称为小子队列）， 然后再分别对这两个队列进行同样的对比操作，一直递归下去，直到子队列的元素小于1。 其实就是基准元素不断归为的过程。
balabala说了一堆，来个例子就明白了：
无序队列： list = {5,2,3,7,9,1}  直接选择排序 这个是比较“笨”的一种算法，就是拿元素一个个比下去。 如果是想升序，就拿每一轮第一个元素和后面的元素比较大小，在每一轮结束后，把找到的最小的元素 交换到该轮起始位置。一共轮 n - 1次。
代码在这里</description>
    </item>
    
    <item>
      <title>这些年，我遇到的哈希、加密算法</title>
      <link>http://shuimu98.gitHub.io/2015-11-24/%E8%BF%99%E4%BA%9B%E5%B9%B4%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%93%88%E5%B8%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 24 Nov 2015 16:50:00 +0800</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2015-11-24/%E8%BF%99%E4%BA%9B%E5%B9%B4%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%93%88%E5%B8%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</guid>
      <description>最近接各种sdk，期间涉及到了很多hash算法、加密算法，虽然之前也一直有接触这些比较常用的算法，也算是熟悉一些常用的算法，起初也不觉得有非常大的必要记录下来，后面想想，还是整理下记录下来，有备无患嘛。
1、hash算法 &amp;ldquo;哈希&amp;rdquo;在工作中常常被提起，主要是把任意长度的输入，通过散列算法，变换成固定长度的输出。比较常见的算法有：MD5、SHA1、HMAC、HMAC_SHA1 等。
很多人将他们称之为加密算法，个人觉得其实他们算不算加密算法，除了其中的HMAC_SHA1需要输入秘钥，其他的都是不需要秘钥的，他们的作用都是计算输入内存的散列值，确保信息传输完整一致。例如很多软件，都会在官网放出软件的MD5、SHA值，主要是确保你下载的软件是否是原版的，确保没有被其他人破解、篡改。
特别注意：哈希算法都是不可逆算法，也就是你无法根据给定的MD5反向解密得出hash前的数据。举个栗子：你可以计算出1G MP4文件的MD5值&amp;rdquo;123456&amp;rdquo;(假设的)，但是你肯定无法根据这个“123456”得到这个1G的MP4，如果可以，那该是多么牛逼的压缩技术，还需要等待漫长的下载吗?找AV得多么幸福啊……
主要注意：SHA1和HMAC_SHA1是有区别的，前者无需秘钥，而后者需要输入秘钥，安全性更好。
下面是用golang写的小代码片段：
import ( &amp;quot;fmt&amp;quot; &amp;quot;crypto/hmac&amp;quot; &amp;quot;crypto/md5&amp;quot; &amp;quot;crypto/sha1&amp;quot; &amp;quot;encoding/hex&amp;quot; &amp;quot;io&amp;quot; ) // 计算md5 func Md5(value string) string { h := md5.New() h.Write([]byte(value)) return fmt.Sprintf(&amp;quot;%s&amp;quot;, hex.EncodeToString(h.Sum(nil))) } // sha1 func Sha1(){ h := sha1.New() io.WriteString(h, &amp;quot;hello,domi~&amp;quot;) signature := fmt.Sprintf(&amp;quot;%x&amp;quot;, h.Sum(nil)) } // hmac_sha1 func HmacSha1() string{ hasher := hmac.New(sha1.New, []byte(&amp;quot;key&amp;quot;)) hasher.Write([]byte(&amp;quot;hello,cat~&amp;quot;)) seg := hasher.Sum(nil) return base64.StdEncoding.EncodeToString(seg) }   Tips:
 关于golang MD5等计算的小问题：</description>
    </item>
    
  </channel>
</rss>