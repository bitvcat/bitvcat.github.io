<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>读书笔记 on Domi●Cat</title>
    <link>http://shuimu98.gitHub.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 读书笔记 on Domi●Cat</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 27 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://shuimu98.gitHub.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>读书笔记 ——《Go语言圣经》</title>
      <link>http://shuimu98.gitHub.io/2018-01-27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/</link>
      <pubDate>Sat, 27 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2018-01-27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/</guid>
      <description>本书中文版，点这里。
接触golang也有两三年了，一直没有系统把它过一遍，正好通过这本书系统性的复习一次，掌握golang的细节。
第1章：入门  命令行参数
os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。os.Args的第一个元素，os.Args[0], 是命令本身的名字（例如：D:\Github\xlsxconv\xlsxconv.exe）。
 bufio包，它使处理输入和输出方便又高效。Scanner类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。它是按流模式读取输入，并根据需要拆分成多个行。理论上，可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们，需要使用ReadFile（来自于io/ioutil）和strings.Split。
input := bufio.NewScanner(os.Stdin) for input.Scan() { // TODO ... }  Printf格式字符串：
   占位符 备注     %d 十进制整数   %x, %o, %b 十六进制，八进制，二进制整数。   %f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00   %t 布尔：true或false   %c 字符（rune） (Unicode码点)   %s 字符串   %q 带双引号的字符串&amp;rdquo;abc&amp;rdquo;或带单引号的字符&amp;rsquo;c&amp;rsquo;   %v 变量的自然形式（natural format）,如果包含的#副词%#v，它表示用和Go语言类似的语法打印值   %T 变量的类型   %% 字面上的百分号标志（无操作数）    {: rules=&amp;ldquo;all&amp;rdquo; frame=&amp;ldquo;border&amp;rdquo;}</description>
    </item>
    
    <item>
      <title>每日笔记 —— golang篇</title>
      <link>http://shuimu98.gitHub.io/2018-01-25/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--golang%E7%AF%87/</link>
      <pubDate>Thu, 25 Jan 2018 15:15:15 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2018-01-25/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--golang%E7%AF%87/</guid>
      <description>目录
 TOC {:toc}  go编译  使用go build编译go文件时，go文件必须放在最后，不然会有named files must be .go files的报错。
例如：go build -ldflags &amp;quot;-w&amp;quot; -o ./xlsx2lua.exe ./xlsx2lua.go
 减小golang编译的二进制文件大小：go build -ldflags &amp;quot;-s -w&amp;quot;，如果想进一步减小，可以使用upx对编译的二进制加壳压缩。
 s去掉符号表（然后panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果） w去掉DWARF调试信息，得到的程序就不能用gdb调试了。  golang发布闭源的.a文件（静态库），参考官方文档 Binary-Only Packages。
  package 别名 import xxx &amp;ldquo;fmt&amp;rdquo; 表示xxx是系统包“fmt”的一个别名，在代码中可以使用 xxx.Println 来调用函数。 &amp;gt;注意，当用一个点 “.”来作为一个包的别名时，表示省略调用，在调用时可以不用写包名，类似c++ 中 using namespace std，以后就不用写std::method这样的格式，但是不推荐。
go可见性规则 首字母大写表示public，小写表示private（注意：作用域是packge，即：在同一个包下，大小写都是可以访问的）。
数组、切片（slice）、map  数组和切片的区别和联系
数组：数组的容量和长度是一样的。cap() 函数和 len() 函数均输出数组的容量（即长度）。 切片：切片是长度可变、容量固定的相同的元素序列。Go语言的切片本质是一个数组。容量固定是因为数组的长度是固定的，切片的容量即隐藏数组的长度。长度可变指的是在数组长度的范围内可变。
 golang map的key：只有function、map和slice三个kind不能作为map的key，struct能不能作为key，要看结构体中的字段是否存在前面所提到的三个类型，如果没有则可以作为key。
 Go语言中的Array、Slice、Map和Set使用详解。
append函数返回值必须有变量接收，因为append操作可能会导致原来的slice底层内存发生改变。
 golang map数据结构不能并发读写问题，最新版本的golang 1.</description>
    </item>
    
    <item>
      <title>每日笔记 —— lua篇</title>
      <link>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--lua%E7%AF%87/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--lua%E7%AF%87/</guid>
      <description>记录从工作至今，工作期间遇到的一些关于lua方面理解不太清晰的部分、相关的新知识等。
 lua的元表和元方法：元表像是一个“操作指南”，里面包含了一系列操作的解决方案，每一个操作的解决方案就是元方法（以__开头的key），例如：__index元方法。 index元方法，引用自这篇文章：
很多人对此都有误解，这个误解是：*如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员。*而这个理解是完全错误的，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil，原因就是B的index元方法没有赋值。别忘了我们之前说过的：“元表是一个操作指南”，定义了元表，只是有了操作指南，但不应该在操作指南里面去查找元素，而index方法则是“操作指南”的“索引失败时该怎么办”。
~~~lua father = {
house=1
}
father.index = father &amp;ndash;注意这一步：把father的__index方法指向自己
son = {
car=1
}
setmetatable(son, father)
print(son.house) ~~~ __index元方法的工作流程：  1.在表中查找，如果找到，返回该元素，找不到则继续 2.判断该表是否有元表（操作指南），如果没有元表，返回nil，有元表则继续 3.判断元表（操作指南）中有没有关于索引失败的指南（即__index方法），如果没有（即__index方法为nil），则返回nil；如果__index方法是一个表，则重复1、2、3； 如果__index是一个函数，则以 table 和 key 作为参数调用它。
  userdata的元表，参考，重点：在lua代码中的普通表，不能作为userdata的metatable。必须使用luaL_newmetatable创建的表才能作为userdata的metatable。luaL_newmetatable创建的元表仅在栈中被声明，并没有加入到lua代码中，所以在lua层是无法访问这个元表的。 lua调用C函数是，先将参数从左往右压栈，然后调用C函数，最后把返回值也压栈，并告诉lua返回了几个值。这个过程lua会自己维护栈。lua调用完C函数后，栈中只会有之前压入的参数，以及返回值，不应该存在其他的值在栈中。 c调用lua函数，要注意栈的变化，lua_pcall 之后，一定要将栈复原。
int st = lua_gettop(svr-&amp;gt;vm); // 调用之前栈大小 lua_pushcfunction(svr-&amp;gt;vm, l_ecb); lua_pushvalue(svr-&amp;gt;vm, svr-&amp;gt;ev_handler[timer_out]); lua_pushinteger(svr-&amp;gt;vm, id); lua_pushboolean(svr-&amp;gt;vm, erased); lua_pcall(svr-&amp;gt;vm, 2, 0, -4); lua_settop(svr-&amp;gt;vm, st); // 调用后，恢复栈  lua正则匹配，主要参考：lua匹配模式和Lua 字符串查找函数以及Step By Step(Lua字符串库)。
   字符 备注     .</description>
    </item>
    
    <item>
      <title>每日笔记 —— 工具篇</title>
      <link>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--%E5%B7%A5%E5%85%B7%E7%AF%87/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--%E5%B7%A5%E5%85%B7%E7%AF%87/</guid>
      <description>1、编辑器 1-1、vim  vim的4种模式，以及模式的切换
Vim常用模式：
 命令模式(command-mode) 插入模式(insert-mode) 可视模式(visual-mode) 正常模式(normal-mode)  Vim各个模式的进入：
①.正常模式：主要用来浏览和修改文本内容的。一般的，打开Vim都是正常模式。在任何模式下，只要按下 Esc 键就可以返回正常模式。
②.插入模式：用来向文本中添加内容的。在正常模式下，按i进入插入模式
③.可视模式：相当于高亮选取文本后的普通模式。在正常模式下，按v进入可视模式，Shift+v进入可视行模式，Ctrl+v进入可视块模式。
④.命令模式：在正常模式下，按:(英文冒号)进入命令模式。
Vim模式的转换：
   原来的模式 新的模式 操作     其它模式 正常模式 按 Esc键   其它模式 插入模式 按 i 在光标前插入
按 I 在行首插入
按 a 在光标后插入
按 s 删除光标所在的字符再插入
按 A 在行末插入
按 o 在当前行之下新建行
按 O 在当前行之上新建行
按 S 删除光标所在行再插入   正常模式 命令模式 按 : （英文冒号）   正常模式 可视模式 按 v 可视模式</description>
    </item>
    
    <item>
      <title>每日笔记 —— 开源项目和学习资料篇</title>
      <link>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E7%AF%87/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E7%AF%87/</guid>
      <description>1、开源项目 1-1、redis  redis项目里面的网络框架（Redis ae事件驱动库）非常不错，称得上是短小精悍，我已经star了两个仓库，在我的star搜索关键字redis。 关于Redis ae事件驱动库的讲解，网上有比较多的教程，例如：教程1 和 教程2  1-2、libev  windows下visual studio编译libev:
 在vs下添加已存在的项目; 从vs中移除ev_epoll.c, ev_kqueue.c, ev_poll.c, ev_select.c, ev_win32.c几个文件; event.c中要包含winsock2.h头文件; config.h.in复制为config.h, 定义HAVE_SELECT和HAVE_SYS_SELECT_H 加上ws2_32.lib  具体参考：https://github.com/xmulyj/libev 里面的README
 关于windows下编译libev的问题:
 1. cygwin下编译正常,有backend; 2. visual studio中编译的话:  (1)把config.h.in复制一份改为config.h,然后HAVE_SELECT和HAVE_SYS_SELECT_H都定义为1后;
(2)在event.c中包含winsock2.h头文件
编译ok, 有backend(select), 运行libev官网上的例子(去掉io watcher,只保留timer watcher)正常.
 libev 教程：可以参考这个大神的博客，里面搜索关键字libev
  1-3、Snowflake算法  Twitter-Snowflake算法，64位自增ID算法，可以用来替换UUID算法。关于该算法的介绍，可以参考这篇文章。
 Snowflake算法，C语言实现。
  1-4、skynet  skynet架构，基本的框架介 以及 Skynet 设计综述。  1-5、raft(分布式系统 RAFT 一致性算法)  raft 简单介绍。  1-6、groupcache  groupcache（已star）是一个分布式缓存 go 语言库,支持多节点互备热数据,有良好的稳定性和较高的并发性。寥寥2000来行代码完成了个lru cache库，核心只用一个list和一个map，出自brad大神之手（memcached作者）。  1-7、UUID生成  rfc4122详细介绍了UUID的生成。在我自己的游戏服务器中有简单的实现并对生成的uuid进行了base64。  2、游戏开发  游戏常用的编程设计模式：游戏编程模式。 行为树：</description>
    </item>
    
    <item>
      <title>每日笔记 —— 计算机原理和操作系统篇</title>
      <link>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2017-10-16/%E6%AF%8F%E6%97%A5%E7%AC%94%E8%AE%B0--%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/</guid>
      <description>1、计算机原理  10进制转16进制计算方法：
注意：所有除法都要取整。
从右数第一位：1610%16 = 10(表示16进制的A),结果： _ _ A
从右数第二位：1610/16 = 100；100%16 = 4,结果：_ 4 A
从右数第三位：100/16 = 6；6%16 = 4,结果：6 4 A
最后： 6&amp;frasl;100 =0 结束运算，最后 转换结果 为: 0x64A
 进制与位元：因为 6个bit就能表示64，所以64进制的位元=6，同理 16进制位元=4，因为2^4=16。
 计算机中原码、反码、补码：
正数的原码、反码、补码都等于原码。
负数的反码=除了最高位的符号位不变，其他位取反。
负数的补码=它的反码+1。
可以看看这篇文章，讲解的比较通俗易懂。
 负数在计算机中是以补码的形式存在，例如有这样一个二进制（1111 1111，其实就是-1），它的最高位是1，所以它是一个负数， 所以它应该是某个负数的反码形式，转换反码为 1111 1110 （补码-1），转换为原码为1000 0001（符号位不变，其他位取反），即1111 1111 表示-1，1000 0000 = -128的补码。
关于补码的计算，在我之前的C primer笔记中有提到。
 总线和寻址范围以及和内存的关系：
假设是32位的总线，那么cpu可以寻址的范围为2的32次方，这里的一根总线代表一个二进制的bit位，注意，这里的bit不是对应的内存bit。这个总线其实可以看成一个索引生成器，它可以给cpu生成2^32个索引。
内存的存储单位为byte，即一个字节 。假如内存是一盒奥利奥，那每一块奥利奥就是一个存储单位，它有8个bit，即一个字节。
通过总线产生的索引，去内存寻址。比如 cpu要寻址的地址 = 0x00000010，那么cpu就会去内存找到索引为 0x00000010 那个存储单元存储的值（一个字节）。
 算术右移：在汇编中，可以用算术右移来进行有符号数据的除法。把一个数右移n位，相当于该数除以2的n次方。</description>
    </item>
    
    <item>
      <title>读书笔记 ——《Unix环境高级编程》</title>
      <link>http://shuimu98.gitHub.io/2017-10-12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 12 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2017-10-12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</guid>
      <description>本书一共21章。
第1章：UNIX基础知识  /etc/passwd文件为unix的口令文件，口令文件中的登陆项由7个以冒号分隔的字段组成，依次是：登录名、加密口令、数字用户id(UID)、组id(GID)、注释字段、起始目录以及使用的shell程序。其中，真实的用户密码存放在/etc/shadow中，组名存放在/etc/group中。
domi:x:500:500::/home/domi:/bin/zsh git:x:502:502::/home/git:/bin/bash  unix文件系统是目录和文件的一种层次结构，所有东西的起点是称为“根”（root）的目录，这个目录的名称是一个字符“/”。
 文件描述符是一个小的非负整数，内核用来标示一个特定进程正在访问（例如：读文件、写文件、新建文件）的文件。
 当运行一个新程序时，shell为其打开3个文件描述符，即标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。可以重定向其中的一个或所有这3个描述符到某个文件。shell把文件描述符0与进程的标准输入关联，描述符1与进程的标注输出关联，描述符2与进程的标准错误关联。 ls &amp;gt; list.txt
 一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关属性。
 当unix系统函数出错时，通常会返回一个负值，而且整数变量errno通常被设置为具有特殊信息的值。
 系统调用（system call）和C库函数调用的区别：   第2章：UNIX标准及实现  两个比较常见的标准,参考这篇文章
 ANSI C：这一标准是 ANSI（美国国家标准局）于 1989 年制定的 C 语言标准。 后来被 ISO（国际标准化组织）接受为标准，因此也称为 ISO C。它的目标是为各种操作系统上的 C 程序提供可移植性保证，而不仅仅限于 UNIX。 POSIX：该标准最初由 IEEE 开发的标准族，部分已经被 ISO 接受为国际标准。POSIX.1 和 POSIX.2 分别定义了 POSIX 兼容操作系统的 C 语言系统接口 以及 shell 和工具标准。这两个标准是通常提到的标准。POSIX 表示可移植操作系统接口（Portable Operating System Interface ，缩写为 POSIX 是为了读音更 像 UNIX）。塔的目标是为了提高 UNIX 环境下应用程序的可移植性，而不仅仅局限于UNIX。  头文件定义了某些与实现相关的数据类型，它们被称为基本系统数据类型。下表列出了常用的基本系统数据类型。  头文件列表</description>
    </item>
    
    <item>
      <title>读书笔记 ——《C Primer Plus》(第5版)</title>
      <link>http://shuimu98.gitHub.io/2017-03-24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-c-primer-plus%E7%AC%AC5%E7%89%88/</link>
      <pubDate>Fri, 24 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://shuimu98.gitHub.io/2017-03-24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-c-primer-plus%E7%AC%AC5%E7%89%88/</guid>
      <description>本笔记是以c99作为标准，而不是最新的c11标准。
c语言关键字 ANSI C一共只有32个关键字，加上ISO推出的C99标准，新增了5个关键字，一共有37个关键字（C99标准）。
把这些关键字按照不同的类型分类，可以分成：数据类型关键字、控制语句关键字、存储类型关键字、函数说明关键字。
数据类型关键字（共15个）    关键字 备注     char 字符类型   short 短整型   int 整型   long 长整型   float 单精度浮点数（6 位有效数字）   double 双精度浮点数（10位有效数字）   signed 声明为有符号类型   unsigned 声明为无符号类型   struct 结构体类型   union 联合类型   enum 枚举类型   void 空类型   _Bool 布尔类型（c99新增，需要包含stdbool.h）   _Complex 复数类型（c99新增）   _Imaginary 虚数类型（c99新增）    {: rules=&amp;ldquo;all&amp;rdquo; frame=&amp;ldquo;border&amp;rdquo;}</description>
    </item>
    
  </channel>
</rss>