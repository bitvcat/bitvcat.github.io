---
layout: post
title: 游戏服务器两种定时器实现
date: 2016-4-8 23:33:00
tags: [算法]
comments: true

---


游戏服务器中的定时器实现一般常见的有两种方式：

- 时间轮（time_wheel）
- 最小堆

就我自己的了解，使用时间轮的开源项目有：云风的skynet、陈硕的muduo；而经典的libevent库则使用的是最小堆。

<!-- more -->

分别解释下最小堆和时间轮的简单概念：

- 最小堆：最小堆是一个经过排序的完全二叉树,除开跟节点，其他任意节点的值都要小于它两个左右孩子的值。

另外关于二叉树的分类，我会另外单独写个笔记整理一下。

>关于完全二叉树，一个n层的二叉树，除了第n-1层是满的（没有空位），第n层右边可以满可以不满，但是从左到右不能出现空位。可使用广度遍历来判断是否是完全二叉树。

- 时间轮：可以直接拿我们生活中的手边做例子，手表一共有三个分级，时钟、分针和秒针，我们把秒针的一个刻度称为一个tick，秒针每走一圈，分针就移动一个刻度，
时间轮的原理就跟手表的模型是一样的。


### 时间轮 

时间轮算法的复杂程度跟你的分级层数有关，最简单的就是只有一轮，我们现在游戏服务器就只使用一轮。

只有一轮的时间轮非常简单，假设需要一个一轮为1分钟的时间轮，每一个tick等于10ms,那么就需要6000个刻度（60s/10ms）。这样时间轮的模型就出来了。

	tick = 10 ms	-- tick
	slotlen = 6000	-- 刻度数量

	下面用lua的table表示这个时间轮的数据结构：
	time_wheel = {
		slots = {
			[1] = {timeobj1,timeobj2,……} -- 刻度1上的定时对象
			[2] = {timeobj1,timeobj2,……} -- 刻度2上的定时对象
		},
		lslot = {t1,t2,……}	-- 这里存放的是tick超过一圈的定时对象
		curTick = 0,		-- 当前走了多少个tick	
	}
	
	timeObj = {
		tick=10, 		-- 表示这个定时对象需要10个tick，
		tickout = 1230,	-- 表示超时的tick，即当定时器tick了1230次后，就触发超时事件
	}
		
	ps：
	关于curTick,这里必须使用无符号，因为curTick是定时器每tick一次就会自增1，而无符号没有溢出的问题，这样可以满足定时器tick到无符号整数能容纳的最大数之后也能继续正确运行。

	举个例子：如果我们有用无符号的32位int表示curTick，那么当curTick一直自增到 0xFFFFFFFF(4294967295)，那么当下一次tick是，curTick又会复位到0，新的tick又会继续运行。

这是我自己用go实现的 [time_wheel](https://github.com/shuimu98/domi-lab/blob/master/golang/time_wheel.go)，比较简单，还有很多需要优化的细节，但是基础都实现了。

当然，上面的这种实现是比较简单的，但是对于游戏服务器来说，这个简单的时间轮已经够用了，如果说想实现更高端的，可以参考[云风skynet里面的时间轮实现](https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_timer.c)。

### 最小堆