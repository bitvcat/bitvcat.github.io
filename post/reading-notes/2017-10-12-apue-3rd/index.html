<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>读书笔记 ——《Unix环境高级编程》 - Domi●Cat</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Domicat" /><meta name="description" content="《Unix环境高级编程》(第3版)的笔记，主要记录每个章节的重点部分，以及需要特别注意的细节。" />

  <meta name="keywords" content="Domi的个人站点, domicat" />






<meta name="generator" content="Hugo 0.44" />


<link rel="canonical" href="http://shuimu98.gitHub.io/post/reading-notes/2017-10-12-apue-3rd/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="读书笔记 ——《Unix环境高级编程》" />
<meta property="og:description" content="《Unix环境高级编程》(第3版)的笔记，主要记录每个章节的重点部分，以及需要特别注意的细节。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shuimu98.gitHub.io/post/reading-notes/2017-10-12-apue-3rd/" />



<meta property="article:published_time" content="2017-10-12T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2017-10-12T00:00:00&#43;00:00"/>











<meta itemprop="name" content="读书笔记 ——《Unix环境高级编程》">
<meta itemprop="description" content="《Unix环境高级编程》(第3版)的笔记，主要记录每个章节的重点部分，以及需要特别注意的细节。">


<meta itemprop="datePublished" content="2017-10-12T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-10-12T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="6774">



<meta itemprop="keywords" content="读书笔记," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="读书笔记 ——《Unix环境高级编程》"/>
<meta name="twitter:description" content="《Unix环境高级编程》(第3版)的笔记，主要记录每个章节的重点部分，以及需要特别注意的细节。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">DomiCat</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/links/">
        <li class="mobile-menu-item">Links</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">DomiCat</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/links/">Links</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">读书笔记 ——《Unix环境高级编程》</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-10-12 </span>
        
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#第1章-unix基础知识">第1章：UNIX基础知识</a></li>
<li><a href="#第2章-unix标准及实现">第2章：UNIX标准及实现</a></li>
<li><a href="#第3章-文件i-o">第3章：文件I/O</a></li>
<li><a href="#第4章-文件和目录">第4章：文件和目录</a></li>
<li><a href="#第5章-标准io库">第5章：标准IO库</a></li>
<li><a href="#第6章-系统数据文件和信息">第6章：系统数据文件和信息</a></li>
<li><a href="#第7章-进程环境">第7章：进程环境</a></li>
<li><a href="#第8章-进程控制">第8章：进程控制</a></li>
<li><a href="#第9章-进程关系">第9章：进程关系</a></li>
<li><a href="#第10章-信号">第10章：信号</a></li>
<li><a href="#第11章-线程-重点">第11章：线程（重点）</a></li>
<li><a href="#第12章-线程控制">第12章：线程控制</a></li>
<li><a href="#第13章-守护进程">第13章：守护进程</a></li>
<li><a href="#第14章-高级i-o">第14章：高级I/O</a></li>
<li><a href="#第15章-进程间通信">第15章：进程间通信</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<p>本书一共21章。</p>

<h2 id="第1章-unix基础知识">第1章：UNIX基础知识</h2>

<ol>
<li><p><code>/etc/passwd文件</code>为unix的口令文件，口令文件中的登陆项由7个以冒号分隔的字段组成，依次是：登录名、加密口令、数字用户id(UID)、组id(GID)、注释字段、起始目录以及使用的shell程序。其中，真实的用户密码存放在<code>/etc/shadow</code>中，组名存放在<code>/etc/group</code>中。</p>

<pre><code>domi:x:500:500::/home/domi:/bin/zsh
git:x:502:502::/home/git:/bin/bash
</code></pre></li>

<li><p>unix文件系统是目录和文件的一种层次结构，所有东西的起点是称为“根”（<code>root</code>）的目录，这个目录的名称是一个字符“<code>/</code>”。</p></li>

<li><p>文件描述符是一个小的非负整数，内核用来标示一个特定进程正在访问（例如：读文件、写文件、新建文件）的文件。</p></li>

<li><p>当运行一个新程序时，shell为其打开3个文件描述符，即标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。可以重定向其中的一个或所有这3个描述符到某个文件。shell把文件描述符0与进程的标准输入关联，描述符1与进程的标注输出关联，描述符2与进程的标准错误关联。
    ls &gt; list.txt</p></li>

<li><p>一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关属性。</p></li>

<li><p>当unix系统函数出错时，通常会返回一个负值，而且整数变量errno通常被设置为具有特殊信息的值。</p></li>

<li><p>系统调用（system call）和C库函数调用的区别：
<img src="/images/posts/syscall_clibcall.jpg" alt="系统调用和库函数调用" /></p></li>
</ol>

<h2 id="第2章-unix标准及实现">第2章：UNIX标准及实现</h2>

<ol>
<li><p>两个比较常见的标准,参考<a href="http://blog.csdn.net/skylj0209/article/details/3071507">这篇文章</a></p>

<ul>
<li><strong>ANSI C</strong>：这一标准是 ANSI（美国国家标准局）于 1989 年制定的 C 语言标准。 后来被 ISO（国际标准化组织）接受为标准，因此也称为 <strong>ISO C</strong>。它的目标是<strong>为各种操作系统上的 C 程序提供可移植性保证，而不仅仅限于 UNIX</strong>。</li>
<li><strong>POSIX</strong>：该标准最初由 IEEE 开发的标准族，部分已经被 ISO 接受为国际标准。POSIX.1 和 POSIX.2 分别定义了 POSIX 兼容操作系统的 C 语言系统接口 以及 shell 和工具标准。这两个标准是通常提到的标准。POSIX 表示可移植操作系统接口（Portable Operating System Interface ，缩写为 POSIX 是为了读音更 像 UNIX）。塔的目标是<strong>为了提高 UNIX 环境下应用程序的可移植性，而不仅仅局限于UNIX</strong>。</li>
</ul></li>

<li><p>头文件<sys/types.h>定义了某些与实现相关的数据类型，它们被称为<strong>基本系统数据类型</strong>。下表列出了常用的基本系统数据类型。
<img src="/images/posts/primitive_system_data_type.jpg" alt="常用的基本系统数据类型" /></p></li>

<li><p>头文件列表</p></li>
</ol>

<p><img src="/images/posts/c99标准头文件.jpg" alt="c99标准头文件" />
<img src="/images/posts/posix必需头文件.jpg" alt="posix必需头文件" />
<img src="/images/posts/posix可选头文件.jpg" alt="posix可选头文件" /></p>

<h2 id="第3章-文件i-o">第3章：文件I/O</h2>

<ol>
<li>文件描述符标志只用于一个进程的一个描述符，而文件状态标志应用于指向该文件表项的任何进程中的描述符。</li>
<li>任何多于一个函数调用的操作都不是原子操作。因为在两个函数调用之间，内核可能会挂起进程。</li>
<li>原子操作指多步操作组成一个操作。执行原子操作，要么执行完所有操作，要么一个操作都不执行。</li>
<li>在<code>/dev/fd</code>目录下，有名为0、1、2等的文件，打开文件/dev/fd/n等效于复制描述符（假定描述符n是打开的）。</li>
</ol>

<h2 id="第4章-文件和目录">第4章：文件和目录</h2>

<ol>
<li><p>unix文件类型</p>

<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>块特殊文件，这种类型的文件提供对设备（如磁盘）带缓冲的访问。</li>
<li>字符特殊文件，这种类型的文件提供对设备（如磁盘）不带缓冲的访问。</li>
<li>FIFO，用于进程间通讯，命名管道。</li>
<li>套接字，用于进程间网络通讯。</li>
<li>符号链接，用于指向另一个文件，类似快捷方式。</li>
</ul></li>

<li><p>文件的访问权限 ： 每个文件有<strong>9</strong>个访问权限位，可以用<code>chmod</code>命令来修改文件的访问权限位，权限位可以分为三组：</p>

<ul>
<li>用户读、用户写、用户执行，用<code>u (user)</code>表示</li>
<li>组读、组写、组执行，用<code>g (group)</code>表示</li>
<li>其他读、其他写、其他执行，用<code>o (other)</code> 表示</li>
</ul></li>
</ol>

<blockquote>
<p>关于文件权限：<a href="http://www.cnblogs.com/123-/p/4189072.html">这篇文章</a>有比较详细易懂的介绍。</p>
</blockquote>

<h2 id="第5章-标准io库">第5章：标准IO库</h2>

<ol>
<li><p>当用标准IO库创建或者打开一个文件时，我们就使用了一个流与文件相关联了。</p></li>

<li><p>对一个进程预定义了3个流，并且这3个流可以自动被进程使用，它们是：标准输入、标准输出和标准错误，这些流所引用的文件与文件描述符<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>,<code>STDERR_FILENO</code>所引用的相同，这三个标准IO流通过预定义文件指针 <code>stdin,stdout,stderr</code>加以引用，这三个文件指针定义在头文件<code>&lt;stdio.h&gt;</code>中。</p></li>

<li><p>标准IO库提供的缓冲目的是为了尽可能减少使用<code>read</code>和<code>write</code>调用的次数，标准IO库提供三种缓冲类型：</p>

<ul>
<li>全缓冲，在填满缓冲区后才进行实际的IO操作</li>
<li>行缓冲，在遇到换行符时，执行IO操作</li>
<li>不带缓冲，不对字符进行缓冲操作存储</li>
</ul></li>
</ol>

<h2 id="第6章-系统数据文件和信息">第6章：系统数据文件和信息</h2>

<ol>
<li><p>时间和日期例程：unix内核提供的基本时间服务是计算UTC（世界标准时间）公元1970年1月1日00:00:00这一特定时间以来的经历过的秒数。</p>

<pre><code class="language-c">#include&lt;time.h&gt;
time_t time(time_t *calptr); // 返回unix时间戳
</code></pre></li>

<li><p>两个函数<code>localtime</code>和<code>gmtime</code>将日历时间（unix时间戳）转换成分解时间，并将结果存放在<code>struct tm</code>结构体中。</p></li>

<li><p><code>localtime</code>和<code>gmtime</code>的区别是：前者将日历时间转换成本地时间，而后者则转换成世界标准时间（UTC）的<strong>年、月、日、时、分、秒、周、日</strong>分解结构。</p></li>
</ol>

<p><img src="/images/posts/unix_time.jpg" alt="各个时间函数之间的关系" /></p>

<h2 id="第7章-进程环境">第7章：进程环境</h2>

<ol>
<li><p>C程序总是从main函数开始执行，main函数的原型如下：</p>

<pre><code class="language-c">int main(int argc, char *argv[]); // argc表示参数数量，argv表示参数
</code></pre></li>

<li><p>进程的终止有<strong>8</strong>种方式，其实5种为正常终止：</p>

<p><strong>正常终止：</strong></p>

<ul>
<li>从main返回</li>
<li>调用exit()或者_Exit(),<code>IOS C</code>标准，头文件<code>stdlib.h</code></li>
<li>调用_exit, <code>POSIX.1</code>标准，头文件<code>unistd.h</code></li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用pthread_exit
<br /></li>
</ul>

<p><strong>异常终止：</strong></p>

<ul>
<li>调用abort()</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ul></li>

<li><p>exit函数总是执行一个标准IO库的清理关闭操作：对于所有打开的流调用fclose函数。</p></li>

<li><p>main函数返回一个整型值与用该值调用exit是等价的，即:<code>return 0;</code>等价于<code>exit(0);</code>，该整型值称为<strong>终止状态</strong></p></li>

<li><p>shell能够获取到进程的终止状态,例如：<code>echo $?</code></p></li>

<li><p><code>IOS C</code>规定一个进程最多可以登记32个函数，这些函数将由exit自动调用，将这些函数称为<strong>终止处理程序</strong>，这些函数由atexit()来登记。</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
int atexit(void (*func)(void));
</code></pre>

<p><img src="/images/posts/crun_and_exit.jpg" alt="C程序的启动与终止" /></p></li>

<li><p>每个程序都接受一张环境表，历史上，大多数unix系统支持main函数带3个参数，第3个参数就是环境表地址：</p>

<pre><code class="language-c">int main(int argc, char *argv[], char *envp[]);
</code></pre>

<p>但是，通常建议只用2个参数，推荐用getenv和putenv函数来访问特定的环境变量。</p></li>

<li><p>C程序的组成部分</p>

<ul>
<li>正文段，这是由CPU执行的机器代码指令部分，可以共享（在存储器中只需要一个副本），并且是只读的</li>
<li>初始化数据段，包含了程序中已经明确赋初始值的变量，例如：<code>int maxcount=99;</code></li>
<li>未初始化数据段，在程序开始执行之前（内核调用exec时），内核将此段的数据初始化为0或者空指针，例如：<code>long sum[100];</code></li>
<li>栈</li>
<li>堆，通常进行动态内存分配，位于<strong>未初始化数据段</strong>与<strong>栈</strong>之间<br /></li>
</ul>

<p>注意：栈向低地址增长；堆向高地址增长。所以，<strong>栈底是在高地址，栈是往下增长</strong>。
<img src="/images/posts/c_mem.jpg" alt="典型的存储空间安排" /></p></li>

<li><p>在C中，goto语句是不能跨函数使用的，而执行这类跳转功能的是函数<code>setjmp</code> 和 <code>longjmp</code>。</p></li>
</ol>

<h2 id="第8章-进程控制">第8章：进程控制</h2>

<ol>
<li>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。</li>
<li>fork的一个特性是父进程的所有打开的文件描述符都复制到了子进程中。</li>
<li>用fork可以创建新进程，用exec可以初始执行新的程序，exit和wait函数处理终止和等待终止，这些是我们需要的基本的进程控制原语。</li>
<li>七个exec函数之间的关系，只有<code>execve</code>属于系统调用，其他6个则为库函数
<img src="/images/posts/exec_function.jpg" alt="七个exec函数之间的关系" /></li>

<li><p>所有现今的unix系统都支持解释器文件（区别于编译器文件），这种文件是文本文件，文件的起始形式：<code>#! pathname [optional-argument]</code>， 当内核调用exec所执行的进程实际执行的并不是该解释器文件，而是解释器文件第一行中的pathname。</p>

<p><strong>举例</strong>：参考<a href="https://www.cnblogs.com/hsl-fly/archive/2013/11/16/3426943.html">这里</a>，下面区分一下在shell命令行上，执行一个shell脚本的不同方式，假设脚本名字为test.sh，脚本位于当前目录:</p>

<ul>
<li><p>(1)输入命令行：sh test.sh，这种方式是在shell中执行/bin/sh程序，然后将test.sh脚本文件作为其参数执行，/bin/sh程序会查找当前目录找到test.sh；</p></li>

<li><p>(2)输入命令行：./test.sh，这种方式就是上面所说的解释器文件的执行过程，shell首先会将test.sh文件当做二进制机器文件，之后会由解释器(根据第一行判断，例如可以是/bin/sh)解释执行。当然，这种方式要求test.sh必须是一个可执行文件，上述(1)可以不是。</p></li>

<li><p>(3)输入命令行：test.sh，这种方式和上述(2)类似，区别是(2)告诉shell在当前目录查找该文件，而该方式下，test.sh的路径必须在系统的环境变量中(即PATH变量)，否则系统找不到该可执行程序文件，值得注意的是PATH变量是没有包含当前目录的。</p></li>
</ul></li>
</ol>

<h2 id="第9章-进程关系">第9章：进程关系</h2>

<h2 id="第10章-信号">第10章：信号</h2>

<ol>
<li><p>在某个信号出现时，可以告诉内核按以下三种方式进行处理，称之为信号的处理。</p>

<ul>
<li>忽略此信号，大多数信号可以使用这种处理方式，<strong>但是</strong>有两种信号决不能被忽略，它们是<code>SIGKILL</code>和<code>SIGSTOP</code></li>
<li>捕捉信号，<strong>注意</strong>，不能捕捉<code>SIGKILL</code>和<code>SIGSTOP</code>信号</li>
<li>执行系统默认动作，<strong>注意</strong>，大多数信号的默认动作是终止进程</li>
</ul>

<p><strong>注意</strong>：不能忽略和捕捉<code>SIGKILL</code>和<code>SIGSTOP</code>信号，也就是说，在你的代码里面，不要去处理这两个信号。</p></li>

<li><p>当一个信号产生时，内核通常在进程表中以某种形式设置一个标示，当对某个信号采取这种动作时，我们说向进程传递了一个信号。在信号产生（generation）和信号传送（delivery）之间的时间间隔内，称信号是未决的（pending）。</p></li>

<li><p>POSIX.1允许系统传送信号一次或多次，如果传送信号多次，则称这些信号进行了排队，但是除非支持POSIX.1实时扩展，否则大多数UNIX系统并不对信号排队，而是只传递信号一次。</p></li>
</ol>

<h2 id="第11章-线程-重点">第11章：线程（重点）</h2>

<ol>
<li>一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述数。</li>
<li>linux2.4和linux2.6在线程上的实现是不同的，前者是用一个单独的进程来实现每个线程，这使得它很难和POSIX线程的行为匹配，而linux2.6采用Native POSIX线程库的新线程实现。</li>

<li><p>如果进程中的任意线程调用了 exit、_exit或者_Exit，那么整个进程就会终止。单个线程可以通过3种方式退出：</p>

<ul>
<li>线程可以简单的从启动例程中返回，返回值是线程的退出码</li>
<li>线程可以被同一个进程中的其他线程取消</li>
<li>线程调用pthread_exit</li>
</ul></li>

<li><p>进程原语和线程原语
<img src="/images/posts/process_and_thread.jpg" alt="进程和线程原语的比较" /></p></li>

<li><p>线程同步</p>

<ul>
<li><p>互斥（mutex）量：从本质上来说就是一把锁，在访问共享资源时对互斥量进行设置（加锁），在访问完后释放（解锁）互斥量。</p>

<p>互斥量相关的5个函数：</p>

<ol>
<li>pthread_mutex_init ，初始化互斥量</li>
<li>pthread_mutex_destroy，销毁互斥量</li>
<li>pthread_mutex_lock，对互斥量加锁，如果互斥量已经上锁，调用线程则阻塞直到互斥量被解锁</li>
<li>pthread_mutex_trylock，尝试对互斥量加锁，如果互斥量已经上锁，该函数会失败，并返回EBUSY，它不会阻塞线程</li>
<li>pthread_mutex_unlock，对互斥量解锁</li>
<li>pthread_mutex_timelock，对互斥量加锁，如果互斥量已经上锁，并且线程阻塞时间超时，则返回错误码ETIMEOUT</li>
</ol>

<p>死锁：
1. 如果线程对同一个互斥量加锁两次，就会陷入死锁。
2. 当线程使用一个以上的互斥量时，如果线程A一直占有一个互斥量MA，并试图锁住第二个互斥量MB时处于阻塞状态，但是拥有第二个互斥量MB的线程B也在试图锁住互斥量MA，因此，两个线程都在相互请求另一个线程所拥有的资源，两个线程都无法向前运行，于是产生死锁。</p>

<p>对于第二种死锁情况，可以想象这样一个电影常见的场景：<strong>两伙黑帮交易，双方都互相不信任，一方想先拿到钱，再给货，另一方想先验货，再付钱，于是就这样焦灼着，这就是两个黑帮的死锁。</strong></p></li>

<li><p>读写锁（reader-writer lock）：与互斥量类似，不过读写锁允许更高的并行性。</p>

<ol>
<li>互斥锁只有两个状态：加锁、不加锁，并且一次只有一个线程可以对其加锁。读写锁有三种状态：读模式下加锁、写模式下加锁、不加锁。一次只有一个线程可以占有写模式下的锁，但是可以多个线程同时占有读模式下的锁。</li>
<li>读写锁的相关函数与互斥量类似，例如：<code>pthread_rwlock_rdlock</code>、<code>pthread_rwlock_wdlock</code></li>
</ol></li>

<li><p>条件变量：条件变量给多个线程提供了一个会合的场所，条件变量和互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。 条件自身是由互斥量保护，也就是说，线程在改变条件状态前必须先锁住互斥量，同理，互斥量必须锁住后才能计算条件。</p>

<p>条件变量的相关函数：</p>

<ol>
<li>pthread_cond_init，初始化一个条件变量</li>
<li>pthread_cond_destroy，销毁</li>
<li>pthread_cond_wait、pthread_cond_timewait，等待条件变为真</li>
<li>pthread_cond_signal，唤醒一个以上等待该条件的线程</li>
<li>pthread_cond_broadcast，唤醒所有等待该条件的线程
<br /></li>
</ol></li>

<li><p>自旋锁：与互斥量类似，但是它不是通过休眠是进程阻塞，而是在获取锁之前一直忙等（自旋），它适用于：锁被持有的时间短，且线程并不希望在重新调度上花费太多成本。</p>

<p>自旋锁和互斥量的区别：<strong>Mutex</strong>属于<code>sleep-waiting</code>类型的锁。例如在一个双核的机器上有两个线程(线程A和线程B)，它们分别运行在Core0和 Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞 (blocking)，Core0 会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而<strong>Spin lock</strong>则不然，它属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在 Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。所以，<strong>自旋锁一般用用多核的服务器。</strong></p></li>

<li><p>屏障：是用户协调多个线程并行工作的同步机制，它允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。<code>pthread_join</code>就是一种屏障，它允许一个线程等待，直到另一个线程退出。</p></li>
</ul></li>
</ol>

<h2 id="第12章-线程控制">第12章：线程控制</h2>

<ol>
<li>如果一个函数在相同的时间点可以被多个线程安全的调用，则称改函数是线程安全的。</li>
<li>支持线程安全函数的操作系统实现会在<unistd.h>中定义符号<code>_POSIX_THREAD_SAFE_FUNCTIONS</code></li>
<li>非线程安全函数以及可以替代的线程安全函数
<img src="/images/posts/unsafe_thread_func.jpg" alt="非线程安全函数" />
<img src="/images/posts/replace_unsafe_thread_func.jpg" alt="可替代的线程安全函数" /></li>
<li>如果一个函数对于多个线程来说是可重入的，就说这个函数是线程安全的，但是这并不说明对信号处理程序来说，该函数也是可重入的，如果函数对于异步信号处理程序的重入是安全的，那么就说该函数是<strong>异步信号安全的</strong>。</li>
<li>一个进程中的所有线程都可以访问进程中的整个地址空间。除了使用寄存器以为，一个线程没有办法阻止另一个线程访问它的数据。</li>
<li><code>pthread_cancel</code>调用并不会等待线程终止，在默认情况下，线程在取消请求发起后还是继续运行，知道线程达到某个<strong>取消点</strong>。取消点是线程检查它是否被取消的一个位置。</li>
</ol>

<h2 id="第13章-守护进程">第13章：守护进程</h2>

<ol>
<li><code>ps</code>命令可以打印系统中各个进程的状态，例如：<code>ps -axj</code>，在ps的输出实例中，内核守护进程的名字出现在方括号中。</li>
<li>在linux中，kthreadd为其他内核进程的父进程。</li>
<li>大多数守护进程都是以超级用户（root）特权运行，所有的守护进程都没有控制终端，其终端名设置为问号，内核守护进程以无控制终端的方式启动。</li>
<li>大多数用户层守护进程都是<strong>进程组的组长进程</strong>以及<strong>会话的首进程</strong>，而且是这些进程组和会话的唯一进程。</li>
<li>用户层的守护进程的父进程是 <strong>init进程</strong>。</li>

<li><p>守护进程与后台进程的区别：</p>

<ul>
<li>后台进程的文件描述符也是继承于父进程，例如shell，所以它也可以在当前终端下显示输出数据。</li>
<li>守护进程自己变成了进程组长，其文件描述符号和控制终端没有关联，是控制台无关的。</li>
<li>基本上任何一个程序都可以后台运行，但守护进程是具有特殊要求的程序，比如要脱离自己的父进程，成为自己的会话组长等，这些要在代码中显式地写出来。换句话说，<strong>守护进程肯定是后台进程，但反之不成立</strong>。</li>
</ul></li>

<li><p>守护进程可以通过<code>syslog</code>来处理出错信息。</p></li>

<li><p>记录和文件锁机制为创建单例守护进程提供了基础。</p></li>
</ol>

<h2 id="第14章-高级i-o">第14章：高级I/O</h2>

<h2 id="第15章-进程间通信">第15章：进程间通信</h2>

<ol>
<li><p>管道，它有两个局限性：</p>

<ul>
<li>它是半双工的（现在某些提供全双工管道）</li>
<li>它只能在具有公共祖先的两个进程之间使用</li>
</ul></li>

<li><p>单进程中使用管道没有任何意义。</p></li>

<li><p>当管道的一端被关闭后，有两条规则：</p>

<ul>
<li>当读一个写端关闭的管道时，当所有数据都读完后，read返回0，表示文件结束</li>
<li>当写一个读端关闭的管道时，则产生信号<code>SIGPIPE</code>。write返回-1，errno设置<code>EPIPE</code></li>
</ul></li>
</ol>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Domicat</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2017-10-12</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/reading-notes/2017-10-16-daily-notes-computer-theory/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">每日笔记 —— 计算机原理和操作系统篇</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/behaviortree/2017-03-24-behavior-tree-1/">
            <span class="next-text nav-default">行为树及其实现</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2017-10-12 00:00:00 \x2b0000 UTC',
    title: '读书笔记 ——《Unix环境高级编程》',
    link: decodeURI(location.href),
    desc: '本书一共21章。 第1章：UNIX基础知识 \/etc\/passwd文件为unix的口令文件，口令文件中的登陆项由7个以冒号分隔的字段组成，依次是',
    owner: 'shuimu98',
    repo: 'shuimu98.github.io',
    oauth: {
      client_id: 'af5065a1372570c7babc',
      client_secret: '3bd955012d21847887f0d3d4f9ea3c2cbc2b7e10'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shui_mu98@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/shuimu98" class="iconfont icon-github" title="github"></a>
  <a href="http://shuimu98.gitHub.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2014 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Domicat</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
