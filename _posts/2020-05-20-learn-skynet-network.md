---
title:  "深入理解skynet —— 网络"
date: 2020-05-20
tag:
- skynet
---

## 前言
当我们接触一些服务器项目时，都会对其中的网络部分有“如临大敌”之感，但其实是我们在理解网络框架时把问题复杂化了，抑或是没有对网络框架划分出一个清晰的层次结构。当我遇到一个框架时，则采用“黑盒化”的一种方式，先把一些较为细节的部分想象成一个黑盒，把它“包”起来，然后对这些黑盒进行梳理，整理好整个框架的大致架构，在这个大框架的基础上再深入“黑盒”中，抽丝剥茧，最终从“黑盒”转变成“白盒”。当然，若配合现实例子能更好的帮助理解。

接下来，带着上面的“利器”，进入到 skynet 的网络世界中吧。

## 网络框架
任何网络框架的核心工作内容其实很简单，即：**接收并读取 socket 中的数据并进行相应处理，然后写入处理后的返回消息**。只不过一个优秀的网络框架会提供更多的功能和细节优化，例如：socket 的管理、网络读写分离、读写数据缓存等等。

skynet 的网络库同样如此，我们对其进行“黑盒化”之后，会得到三个部分：网络工作线程(`thread_socket`)、网络服务管理器(`socket_server`)、内部命令。然后对这三个“黑盒”梳理串联，就得到了整个网络库的的核心工作流程：CPU 驱动网络线程运行，线程则调用网络服务的 poll (`skynet_socket_poll`)接口，进而推动外部网络处理和内部网络命令。正如云风大佬所说：
>skynet 网络层的设计目的是，把操作系统层面的 socket 数据从系统内核复制到用户空间，然后再把用户空间的数据地址交给各个不同的服务使用，同时也把用户空间需要发送的数据转移到系统内核中。

为了更具象的描述上面的流程，我举一个“接地气”的例子：中国乡下都能见到的个体家用榨油机，例如最常见的菜籽榨油机，往榨油机漏斗倒入油菜籽，经由机器压榨，最后流出菜籽油。细细品味一下，你会发现这跟上面提到的 skynet 网络库的处理流程是不是大同小异？这种家用榨油设备不就是一个简化版的（*只处理一个socket*）的“网络库”吗，它由 **CPU**（“电机”）驱动 **poll 接口**（“传动轮”）而工作，读取**输入数据**（“油菜籽”），然后**处理数据**（“压榨”），最后**返回结果**（“菜籽油”），还能自我控制（“调节漏斗流量”）。

![家用榨油机](/assets/image/posts/2020-05-20-01.jpg?style=centerme)
<p align="center"><em>家用榨油设备</em></p>

### 网络线程
skynet 使用了一个单独的唯一线程来完成所有网络连接的收发，网络线程代码如下：
```c
static void *
thread_socket(void *p) {
	struct monitor * m = p;
	skynet_initthread(THREAD_SOCKET);
	for (;;) {
		int r = skynet_socket_poll();
		if (r==0)
            // 退出网络轮询，即网络线程退出
			break;
		if (r<0) {
			CHECK_ABORT
            // 一般r=-1,表示还有剩余网络事件需要处理
			continue;
		}

        // r>0, 表示捕获到新的网络事件，若所有worker全部都处于sleep，则唤醒一个
		wakeup(m,0);
	}
	return NULL;
}
```

此线程的逻辑非常简单，它会循环调用 poll 接口，并根据返回值来确定继续或退出线程。关于其返回值，我已经在上面代码注释中有描述，这里着重探讨 poll 接口：`skynet_socket_poll`，它调用了网络库底层的`socket_server_poll`接口，该接口处理由操作系统提供的多路复用IO接口所捕获到的网络事件，包括内网网络命令和外部网络消息，然后根据其处理后的返回的网络消息类型，将返回结果转发给对应的服务（context）。
>skynet 的多路复用IO接口支持 unix-like 系统的跨平台，linux (例如centos、ubuntu等)使用 epoll；unix (MacOS、FreeBSD等)使用kqueue。

### 网络管理器
管理器对应了网络库中的 socket_server 实例（或称对象），这里只简单阐述下它的作用，我在下一节中对其做了详细的剖析。

它主要大致可分为两个：
1. socket 的管理，包括 socket的存储、socket 的id分配以及socket 状态的维护等等；
2. 网络事件的处理，包括 efd 的创建、管道的创建与读写处理（用于内部命令）、外部网络事件的捕获与读写处理等。关于网络（内部和外部）的读写处理封装在 `socket_server_poll` 接口中，供网络线程调用，后面也有详细剖析。

## socket_server
### 管道
### 事件

## socket 封装
### socket 状态
### 写入队列
### dw_buffer

## 消息的封装
### skynet_message
### socket_message
### skynet_socket_message

## 网络处理
### 内部命令
### 消息读取
### 消息写入

## lua库
### socketdriver
### netpack

<hr>
**参考：**
- [skynet 网络层的一点小优化](https://blog.codingnow.com/2019/11/skynet_socket_rawpointer.html)
