---
layout: post
title:  "读书笔记 ——《C Primer Plus》(第5版)"
date:   2017-03-24
excerpt: "《C Primer Plus》(第5版)的笔记，主要记录每个章节的重点部分，以及需要特别注意的细节。"
tag:
- 读书笔记
comments: true
---

本笔记是以**c99**作为标准，而不是最新的**c11**标准。

## c语言关键字


ANSI C一共只有32个关键字，加上ISO推出的C99标准，新增了5个关键字，一共有37个关键字（C99标准）。

把这些关键字按照不同的类型分类，可以分成：数据类型关键字、控制语句关键字、存储类型关键字、函数说明关键字。

### 数据类型关键字（共15个）

| 关键字        	   | 备注           				|
| ---------------- |:---------------------------|
| char             | 字符类型                   |
| short            | 短整型                     |
| int              | 整型                       |
| long             | 长整型                     |
| float            | 单精度浮点数（6 位有效数字） |
| double           | 双精度浮点数（10位有效数字） |
| signed           | 声明为有符号类型            |
| unsigned         | 声明为无符号类型            |
| struct           | 结构体类型                  |
| union            | 联合类型                    |
| enum             | 枚举类型                    |
| void             | 空类型                      |
| _Bool            | 布尔类型（c99新增，需要包含stdbool.h）|
| _Complex         | 复数类型（c99新增）          |
| _Imaginary       | 虚数类型（c99新增）          |
{: rules="all"}

### 控制语句关键字（共12个）

| 关键字        	   | 备注           				|
| ---------------- |:---------------------------|
| for              | for循环                    |
| do               | do..while循环结构          |
| while            | while循环                  |
| break            | 跳出循环                   |
| continue         | 结束当前循环，继续下一个循环 |
| if               | if条件语句                  |
| else             | 条件语句否定分支            |
| goto             | 无条件跳转                  |
| switch           | 开关语句                   |
| case             | 开关语句分支                |
| default          | 开关语句的默认分支          |
| return           | 返回语句                   |
{: rules="all"}

### 存储类型关键字（共9个）

| 关键字        	   | 备注           				|
| ---------------- |:---------------------------|
| auto             | 声明自动变量                |
| extern           | 重新声明已经在其他地方定义过的变量|
| register         | 声明寄存器变量              |
| static           | 静态类型                    |
| sizeof           | 计算数据类型或变量长度（即所占字节数） |
| typedef          | 数据类型别名               |
| const            | 声明只读变量            		|
| volatile         | 说明变量在程序执行中可被隐含地改变|
| restrict         | 仅用于指针，表明指针是访问一个数据对象唯一的方式|
{: rules="all"}

### 函数说明关键字（共1个）

| 关键字        	   | 备注           				|
| ---------------- |:---------------------------|
| inline           | 内联函数声明                |
{: rules="all"}

ps：前两章节，都是介绍c语言，所以，忽略掉这两章的内容，该笔记重点记录从第三章开始的内容。

## 第三章：数据和C

- C仅保证short类型不会比int类型长，并且long类型不会比int类型短。这样做是为了适应不同的机器。  
**个人理解**：C并没有规定int类型必须是4字节，具体每个类型占用多少字节，需要根据不同的平台定义。但是C保证int至少有16位，short至少是16位，long至少为32位，long long至少是64位。**特别的**，char类型肯定为1个字节，因为C把char类型的长度定义为1字节。

- _Bool类型由C99引入，用于表示布尔值，即逻辑值true（真）与false（假）。因为C用值1表示true，用值0表示false，所以_Bool类型实际上也是一种整数类型。只是原则上它仅仅需要1位来进行存储。因为对于0和1而言，1位的存储空间已经够用了。  
**提醒**：如果需要用到bool变量，需要包含stdbool.h头文件

- 如果想把一个比较小的值作为long对待，可以使用`L`作为后缀。例如：`long a = 123L`，与之类似，使用`LL`后缀表示long long，使用`ULL`表示unsinged long long。

- 打印占位符:%d打印有符号整型，%o打印八进制，%x打印16进制，u%打印无符号整型，ld%打印长整型（long int)，lld%打印long long，%c打印字符，%s打印字符串，%f打印float和double（%e表示以指数形式打印），%lf打印long float。

- 可移植的类型，需要包含头文件`inttypes.h`，可以明确知道一个int是否是16位还是32位，例如：int16_t,uint32_t。

- 默认情况下，编译器会把浮点常量当做double类型对待。C可以使用`F`后缀告诉编译器把一个浮点常量做为float看待，例如：1.23F，如果想做为long double看待，可以使用后缀`L`,例如：5.14L。  
**提醒**:这里的L和前面的long类型的L是有区别的。一个是long int，一个是long double。

- 浮点数需要注意上溢和下溢的情况，另外浮点数会存在一个特殊的值NaN（Not a Number），例如：90度的正切值（tan90°）就是不存在的。

- **注意**，使用％d显示float值不会把该float值转换为近似的int值，而是显示垃圾值。与之类似，使用％f显示int值也不会把该int值转换为浮点值。而且，参数的数目不足和类型不匹配所造成的结果也将随平台不同而不同。例如：`int a=100; printf("a=%f\n",a)`;此时可能输出a=0.000000。

- C有多种数据类型。基本的数据类型包含两大类：整数类型和浮点类型。整数类型的两个重要特征是其类型的大小以及它是有符号还是无符号的。最小的整数类型是char，因实现不同可以是有符号或无符号的（使用singed 或 unsigned）。

## 第四章：字符串和格式化输入/输出

- `scanf()`开始读取输入以后，会在遇到的第一个**空白字符空格**（blank）、**制表符**（tab）或者**换行符**（newline）处停止读取。一般情况下，使用％s的`scanf()`只会把一个单词而不是把整个语句作为字符串读入。C使用其他读取输入函数（例如`gets()`）来处理一般的字符串。

- C头文件limits.h和float.h分别提供有关整数类型和浮点类型的大小限制的详细信息。例如：`#define INT_MAX	 2147483647`

- 不能在引号括起来的字符串中间断行，但是C的新方法：如果在一个用双引号引起来的字符串后面跟有另一个用双引号引起来的字符串，而且二者之间仅用空白字符分隔，那么C会把该组合当作一个字符串来处理。例如：

		printf("this is test
		text.");//错误
		printf("this is test"
		"text.")//正确

- 使用`scanf()`的两点规则：1、如果使用scanf()读取某种基本变量类型的值，请在变量名之前加上一个`&`；2、如果使用scanf()把一个字符串读进一个字符数组中，请不要使用& 。
		
		int a;
		char b[32];
		scanf("%d %s",&a,b);

## 第五章：运算符、表达式和语句

- C大约有40个运算符，包括赋值运算符`=`，算术运算符`+、-、*、/`（C没有指数运算符，但是提供了pow()函数，例如：pow(3,5)）、关系运算符（`>,<,>=,<=,==,!=`）、逻辑运算符(`非!，与&&，或||`)以及其他运算符，sizeof()(计算右操作数的字节大小)，(type)指派运算符(用于类型转换，例如：`a = (int)3.14;`)，逗号运算符等；

- C99要求使用“趋零截尾”，例如:`-3.8`转换成`-3`

- C规定sizeof返回size_t类型的值。这是一个无符号整数类型，但它不是一个新类型。相反，与可移植类型（如int32_t等）相同，它是根据标准类型定义的。

- 取模运算符`%`用于整数运算。该运算符计算出用它右边的整数去除它左边的整数得到的余数。例如，13%5（读作“对13除以5取模”）所得值为3,因为13除以5得2并余3。**不要对浮点数使用该运算符，那将是无效的**，另外，对**负数取模，结果都是负数**。

- 要一次使用太多增量运算符，因为多个增量的顺序无法保证（少一点奇技淫巧）。

- 关于类型转换：类型级别从高到低的顺序是`long double`、`double`、`float`、`unsigned long long`、`long long`、`unsigned long`、`long`、`unsigned int`和`int`。一个可能的例外是当long和int具有相同大小时，此时unsigned int比long的级别更高。之所以short和char类型没有出现在此清单里，是因为它们已经被提升到int或unsigned int。

- 应该避免自动类型转换，尤其是避免降级。当需要准确的类型转换，可以使用指派运算符（type）。

- 如果函数不接受参数，函数头里的圆括号将包含关键字void。

- 函数中的变量名字是局部的。这意味着在一个函数里定义的名字不会与其他地方相同的名字发生冲突。  
**个人理解**：函数的形参（形式参数）是局部变量，是函数所私有的，如同在函数内部定义的局部变量一样。

## 第六章：C控制语句:循环

- 一般地，所有的**非零值都被认为是真**，只有0被认为是假。C对真的范围放得非常宽！

- **逗号运算符**把两个表达式链接为一个表达式，并保证最左边的表达式最先计算。它通常被用在for循环的控制表达式中以包含多个信息。整个表达式的值是右边表达式的值。

- for循环中，如果中间的那个控制表达式为空会被认为是真，即这个for循环则会永远执行（死循环）；

## 第七章：C控制语句:分支和跳转

- C有一系列标准的函数可以用来分析字符。`ctype.h`头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特定的种类则返回非零值（真），否则返回零（假）。例如，如果`isalpha()`函数的参数是个字母，则它返回一个非零值。

- C99标准为逻辑运算符增加了可供选择的拼写法。它们在`iso646.h`头文件里定义。如果包含了这个头文件，就可以用`and`代替`&&`，用`or`代替`||`，用`not`代替`!`。

- switch 标签页范围从3-999

## 第八章：字符的输入和输出、输入确认

- 缓冲分为两类：**完全缓冲（fully buffered）I/O**和**行缓冲（line-buffered）I/O**。对完全缓冲输入来说，缓冲区满时被清空（内容被发送至其目的地）。这种类型的缓冲通常出现在文件输入中。缓冲区的大小取决于系统，但512字节和4096字节是常见的值。对行缓冲I/O来说，遇到一个换行字符时将被清空缓冲区。键盘输入是标准的行缓冲，因此按下回车键将清空缓冲区。

- 不必定义EOF，因为stdio.h负责定义它。`#define EOF (-1)`

- 重定向是一个命令行概念，要通过在命令行键入特殊符号来指示它，一般为`>`输出重定向，`<`输入重定向。


## 第九章：函数

- ANSI C形式要求在每个变量前声明其类型。也就是说，不能像通常的变量声明那样使用变量列表来声明同一类型的变量。

		void test(int a,b,c);//错误
		void test(int a, int b, int c);//正确

- 当函数的实际返回值类型与函数原型声明的返回值类型不同时，实际返回值是把**指定的要返回的值**赋给一个**具有所声明的返回类型的变量**时得到的数值。例如：

		int test(){
			double a=1.2;
			return a; // 相当于把a的值赋值给一个int变量，然后返回这个int变量
		}

- return语句的另一作用是终止执行函数，并把控制返回给调用函数的下一个语句。即使return语句不是函数的最后一个语句，其执行结果也是如此。

- 不要把函数声明和函数定义混淆。**函数声明**只是将函数类型告诉编译器，而**函数定义**部分则是函数的实际实现代码。

- 如果实参类型与形参类型不匹配，但都是数值类型，编译器会把实际参数值转换成和形式参数类型相同的数值。

- C编译器会假设没有用函数原型声明函数，它就不会进行参数检查。因此，为了表示一个函数确实不使用参数，需要在圆括号内加入void关键字。  
**个人理解**：为了让编译器为你检查函数参数，最好先申明一个函数原型。

- **有一种方法**可以不使用函数原型却保留函数原型的优点：可以在首次调用某函数之前对该函数进行完整的定义。

- 递归一般可以代替循环语句使用，两种方式各有优缺点，**递归执行效率没有循环语句高**。  
**提醒**：递归效率比循环低，是因为每次递归调用都拥有自己的变量集合，所以就需要占用较多的内存；每次递归调用需要把新的变量集合存储在堆栈中。其次，由于进行每次函数调用需要花费一定的时间，所以递归的执行速度较慢。

- 一个程序中的每个C函数和其他函数之间是平等关系。每一个函数都可以调用其他任何函数或被其他任何函数调用。

- ANSI C中的%p格式对地址进行输出。例如：`printf("ptr = %p\n",p); //p必须是一个指针变量`。

- 指针的值是一个**地址**，在大多数系统内部，它由一个**无符号整数**表示。但是，这并不表示可以把指针看作是整数类型。一些处理整数的方法不能用来处理指针，反之亦然。例如：可以进行两整数相乘，而指针则不能。因此**指针的确是一种新的数据类型**，而不是一种整数类型。


## 第十章：数组和指针（重点）

- 只读数组(例如：`const char str[10]`)，程序从数组中读取数值，但是程序不向数组中写数据。

- 当数值数目少于数组元素数目时，多余的数组元素被初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的是无用的数值；但是如果部分初始化数组，未初始化的元素则被设置为0。

- 声明数组的两种方式：1、直接指定数组的大小，例如：`int a[3] = {1,2,3}`；2、省略括号中的数字，从而让编译器会根据列表中的数值数目来确定数组大小，例如：`int a[]={1,2,3}`。  
**注意**： 第二种方式需要在声明的同时并初始化数组。

- C99规定，在初始化列表中使用带有方括号的元素下标可以指定某个特定的元素，例如：`int arr[10]={[7]=100};`，而未经初始化的元素都被设置为**0**。

- C不支持把数组作为一个整体来进行赋值，也不支持用花括号括起来的列表形式进行赋值（初始化的时候除外）。

		int a[10];
		int b[10];
		b=a;//错误
		a={1,2,3};//错误

- 编译器不检查索引的合法性。在标准C中，如果使用了错误的索引，程序执行结果是不可知的。也就是，程序也许能够运行，但是运行结果可能很奇怪，也可能会异常中断程序的执行。  
**注意**：不检查数组边界。

### 变长数组  

- C99引入变长数组，即：`int a=10; int arr[a];`，但是，变长数组声明时，不能进行初始化。
- 变长数组必须是自动存储类的，这意味着它们必须在函数内部或作为函数参量声明，而且声明时不可以进行初始化。
- 变长数组中的“变”并不表示在创建数组后，您可以修改其大小。变长数组的大小在创建后就是保持不变的。“变”的意思是说其维大小可以用变量来指定。
- 声明一个含有二维变长数组的函数，`int sum(int rows,int cols,int arr[rows][cols]);`，但是在参量列表中，代表数组大小的变量声明需要早于变长数组。
- 可以省略函数原型中的参数名称，但是需要用星号来省略维数，例如：`int sum(int ,int ,int arr[*][*]);`


### 数组与指针的关系

关于指针和数组的理解:

我们可以想象这样一个场景，就是我们学生时代的班级，假设一个班有35个同学，有5个小组，每个小组有7个同学。一个一维数组（`int group[7]`）就像是班级里面的一个组，我们在每个组的第一个座位前钉一个牌子，比如：**一组**、**二组**等，牌子上写的名字就是数组名`group`，它也就等同于指向这个组的指针，即一个组第一个同学的座位。而二维数组(`int class[5][7]`)就可以想象成整个班级，班级名（比如三年二班）就相当于二维数组的数组名`class`，它也等同于指向班级第一组第一个同学的座位。

关于const数组/指针的理解，`const int group[7]`表示这个组的同学都已经固定好了，不能修改。`const int *const pGroup`表示不仅不能修改这一组的同学，连每个组牌子上的名字也不能修改。

下图是一个二维数组的内存结构：

![二维数组](/images/posts/two-dimension_array.png)  

- 数组与指针的关系：**数组名是该数组首元素的地址**。对于数组而言，地址会增加到下一个元素的地址，而不是下一个字节。同时，可以用指针标识数组的每个元素，并得到每个元素的数值。从本质上说，对同一个对象有两种不同的符号表示方法。  
**例子**：定义ar[n]时，意思是*(ar+n)，即“寻址到内存中的ar，然后移动n个单位，再取出数值”。

- 在函数原型或函数定义头的场合中（并且也只有在这两种场合中），可以用`int *ar`代替`int ar[]`。


- 处理数组的函数实际上是使用指针做为参数的，也就是说把数组作为参数传递给函数时，会把数组转换为指针处理。

- 指针的两个操作：1、赋值，把一个地址赋值给指针；2、求差值，求出两个元素之间的距离（并非是字节数差距）；

- 使用指针时，特别注意：**不能对未初始化的指针取值**。另外**切记**：当创建一个指针时，系统只分配了用来存储指针本身的内存空间，并不分配用来存储数据的内存空间。因此在使用指针之前，必须给它赋予一个已分配的内存地址。

- 可以使用两个const来创建指针，这个指针既不可以更改所指向的地址，也不可以修改所指向的数据。例如：`const char *const p;`

- 一般地，声明N维数组的指针时，除了最左边的方括号可以留空之外，其他都需要填写数值。 这是因为首方括号表示这是一个指针，而其他方括号描述的是所指向对象的数据类型。

		int sum(int arr[][12][20][30]);
		int sum(int (*p)[12][20][30]); //效果同上

- 

未完待续……