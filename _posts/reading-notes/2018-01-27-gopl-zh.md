---
layout: post
title:  "读书笔记 ——《Go语言圣经》"
date:   2018-01-27
excerpt: "Go语言圣经 《The Go Programming Language》 中文版本笔记"
tag:
- 读书笔记
comments: true
---

本书中文版，点[这里](https://books.studygolang.com/gopl-zh/index.html)。


## 第1章：入门

1. 命令行参数

	`os`包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。**os.Args的第一个元素**，`os.Args[0]`, 是命令本身的名字（例如：`D:\Github\xlsxconv\xlsxconv.exe`）。

2. `bufio`包，它使处理输入和输出方便又高效。Scanner类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。它是按**流**模式读取输入，并根据需要拆分成多个行。理论上，可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们，需要使用`ReadFile`（来自于`io/ioutil`）和`strings.Split`。
	
	```go
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
	   	// TODO ...
	}
	```
3. `Printf`格式字符串：

	| 占位符        	   	| 备注           									|
	| :---------------: |:-------------------------------------------------	|
	|%d          		|十进制整数|
	|%x, %o, %b  		|十六进制，八进制，二进制整数。|
	|%f, %g, %e  		|浮点数： 3.141593 3.141592653589793 3.141593e+00|
	|%t          		|布尔：true或false|
	|%c          		|字符（rune） (Unicode码点)|
	|%s          		|字符串|
	|%q          		|带双引号的字符串"abc"或带单引号的字符'c'|
	|%v          		|变量的自然形式（natural format）|
	|%T          		|变量的类型|
	|%%          		|字面上的百分号标志（无操作数）|
	{: rules="all" frame="border"}

4. 如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个&符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。
5. Go语言里的switch可以不带操作对象；可以直接罗列多种条件，像其它语言里面的多个if else一样。这种形式叫做无tag switch(tagless switch)；这和switch true是等价的。

	```go
	func Signum(x int) int {
	    switch {
	    case x > 0:
	        return +1
	    default:
	        return 0
	    case x < 0:
	        return -1
	    }
	}
	```
6. 指针是可见的内存地址，&操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作(可以通过unsafe包进行指针运算，具体参考[我的golang每日笔记](http://domicat.me/daily-notes-golang/#%E6%8C%87%E9%92%88))。

## 第2章：程序结构
1. go有25个关键字，30多个内建的预定义字，可以参考源码的`Go\src\builtin\builtin.go`。
2. go推荐使用 **驼峰式** 命名。
3. Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。
4. 用`new`创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。所以下面的两个`newInt`作用是相同的：

	```go
	func newInt() *int {
	    return new(int)
	}
	
	func newInt() *int {
	    var dummy int
	    return &dummy
	}	
	```

5. 如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和 [0]int, 有可能有相同的地址。所以**谨慎使用大小为0的类型**，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档。
6. 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，**这个选择并不是由用var还是new声明变量的方式决定的**（这与C语言是有区别的）。当返回一个局部变量的指针时，用Go语言的术语说，这个**局部变量从函数中逃逸**了。记住的是，**逃逸的变量需要额外分配内存**，同时对性能的优化可能会产生细微的影响。具体看下面的例子：

	```go
	var global *int
	
	func f() {
	    var x int
	    x = 1
	    global = &x // 此时x被分配到堆上
	}
	
	func g() {
	    y := new(int)	// 此时y分配在栈上
	    *y = 1
	}
	```

7. 数值变量也可以支持++递增和--递减语句，注意：go只有**后置**没有前置，因此`++i`这种是错误的。另外：自增和自减是语句，而不是表达式，因此`x = i++`之类的表达式是错误的。
8. nil可以赋值给任何指针或引用类型的变量（slice、map、chan）。
9. 按照惯例，一个**包的名字和包的导入路径的最后一个字段相同**，例如`gopl.io/ch2/tempconv`包的名字一般是`tempconv`。
10. 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件**根据文件名排序，然后依次调用编译器编译**。


## 第3章：基础数据类型

1. Go语言将数据类型分为四类：**基础类型**、**复合类型**、**引用类型**和**接口类型**。
2. 在Go语言中，**%取模运算符的符号和被取模数的符号总是一致的**，因此`-5%3`和`-5%-3`结果都是-2。
3. Go语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数：

	- `&`      位运算 AND
	- `|`      位运算 OR
	- `^`      位运算 XOR
	- `&^`     位清空 (AND NOT)
	- `<<`     左移
	- `>>`     右移

	关于左移和右移：请参考[C语言笔记的位运算部分](http://domicat.me/c-primer-plus/#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E4%BD%8D%E6%93%8D%E4%BD%9C)。
	
	关于`&^`运算符（`a &^ b`）：此运算符是双目运算符，按位计算，功能等同于以a&(^b)，如果右操作数的bit位为1，则将左操作数的对应bit位置零，类似一个掩码，用于置零对应的bit位。和它等价的c语言运算符表达式：等价于c语言里的&=~

	```c
	int a = 3;
	a &= ~1;
	```

4. 注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时：

	- `%`之后的**[1]**副词告诉Printf函数再次使用第一个操作数
	- `%`后的**#**副词告诉Printf在用`%o`、`%x`或`%X`输出时生成`0、0x、0X`前缀

	```go
	o := 0666
	fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
	x := int64(0xdeadbeef)
	fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
	// Output:
	// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
	```

5. Go语言提供了两种精度的浮点数，`float32`和`float64`。一个float32类型的浮点数可以提供大约**6个**十进制数的精度，而float64则可以提供约**15个**十进制数的精度。float32的有效bit位只有**23个**，float64的有效bit位只有**53个**，其它的bit位用于指数和符号。

6. 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数（不合法的数学结果）对应的值。注意，`不要用NaN做比较预算，因为NaN和任何数都是不相等的`。

	```go
	nan := math.NaN()
	fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
	```

7. 字符串，每一门语言比较难以理解的都是字符串（个人感觉），golang中的字符串是一个基础类型（`string`），它与C语言中的字符串有一些区别。golang中字符串底层实现如下：

	```c
	struct string {
	  byte* str;
	  int len;
	}
	```

	因此，可以看出它和C语言字符串的区别，它并不是以`\0`字符作为字符串结束的依据，因为它已经明确指出了字符串的长度`len`。另外需要注意的是，空字符在C语言和golang中的表示也是有区别的：C语言是`\0`，golang是`\x00`（`fmt.Println("hello\x00world")`）。

8. 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。

	```go
	s := "aaa"
	s += "bbb" //合法
	s[0] = 'c' //不合法，编译错误
	```
	
	不可修改意味着：**如果两个字符串共享相同的底层数据的话也是安全的**。
9. 字符串可以转换成`[]byte`和`[]rune`，前者是转换成字符数组，后者是转换成Unicode码点数组。
	
	
	```go
	var s string = "abcd你好"
	sb:=[]byte(s)
	sr:=[]rune(s)
	fmt.Println(sb,sr)
	```

10. 标准库中有四个包对字符串处理尤为重要：**bytes、strings、strconv和unicode包**。

	- strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
	- bytes包也提供了很多类似string包功能的函数，但是针对[]byte类型。
	- strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
	- unicode包提供了处理unicode相关的功能函数

11. 一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。

	```go
	const pi = 3.14159265358979
	const noDelay time.Duration = 0
	const timeout = 5 * time.Minute
	```

12. 常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。

	```go
 	type Weekday int

	const (
	    Sunday Weekday = iota	// 0 
	    Monday					// 1
	    Tuesday
	    Wednesday
	    Thursday
	    Friday
	    Saturday
	)
	```

13. Go语言的常量有个不同寻常之处。虽然一个常量可以有任意有一个确定的基础类型，例如int或float64，但是**许多常量并没有一个明确的基础类型**(只有常量可以是无类型的)。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算；可以认为**至少有256bit的运算精度**。

	这里有六种未明确类型的常量类型，分别是**无类型的布尔型**、**无类型的整数**、**无类型的字符**、**无类型的浮点数**、**无类型的复数**、**无类型的字符串**。


## 第4章：复合数据类型

1. golang的数组与C语言中的数组是一样的，都是分配在一块连续的、有固定长度的内存中。同时，它是slice实现的基础。
2. 在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。

	```go
	q:=[...]int{1,2,3}
	fmt.Printf("%T,%[1]v\n",q) // [3]int,[1 2 3]
	```

	此外，还有另一种形式的数组字面值，可以指定某个索引的值，其他未指定的值，则初始化为零值。

	```go
	x := [3]int{1:100}
	y := [...]int{9: -1} //数组长度为10
	fmt.Println(x,y) // output: [0 100 0] [0 0 0 0 0 0 0 0 0 -1]
	```
3. 关于数组的指针，golang和C语言是有所区别的，在C语言中，数组名可以表示指向数组起始位置的指针，而golang中数组的指针要明确指出数组类型。

	```go
	b:=[5]byte{'a','b'}
	var ptr *[5]byte
	var ptr1 *[10]byte
	ptr = &b
	ptr1= &b // compile error: cannot use &b (type *[5]byte) as type *[10]byte in assignment
	fmt.Printf("%+v,%[1]T,%c,%c",ptr,(*ptr)[0],ptr[0]) // output: &[97 98 0 0 0],*[5]uint8,a,a
	```

4. TODO