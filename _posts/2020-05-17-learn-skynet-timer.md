---
title:  "深入理解skynet —— 定时器"
date: 2020-05-17
tag:
- skynet
---

定时器（timer）模块是整个 skynet 框架中最为简单、耦合度最低一个模块，但也是一个不可或缺的模块，游戏中有很多玩法功能都依赖于定时器，例如：在线时长礼包、玩家上的buff 和 debuff 等等。

在 skynet 中，使用了时间轮（time wheel）算法来实现定时器模块，定时器的逻辑由专门的线程（`thread_timer`）进行负责，节点中的服务向定时器注册定时消息，然后由 timer 线程每隔一段时间转动一次时间轮（在 skynet 中，每隔 10 ms 转动一次时间轮），由此触发该轮下的定时消息，并派发定时事件到对应的服务。

>关于定时器的实现算法主要有两种：最小堆和时间轮。redis 使用了最小堆（我印象中早期是使用的最小堆，后面的版本没有关注）；linux 内核使用了时间轮。

## 时间轮

时间轮算法的本质就是**用有限的刻度实现时间的无限轮回**，一次时间轮回的长度就是该时间轮能表达的最大时长。其实现方式就是模拟了我们生活中的手表（机械手表），只不过手表把**时、分、秒**三个轮盘合并成了一个轮盘，而把刻度指针分为了三个。

现在，我们把手表的轮盘按照时、分、秒拆分成三个，它们的轮盘刻度分为为：12（时）、60（分）、60（秒），因此手表的时间轮模型一共有 `12 + 60 + 60 = 132` 个刻度，走完一整轮的时长为 `12 * 60 * 60 = 43200` 秒。

![手表的时间轮模型](/assets/image/posts/2020-05-17-01.png?style=centerme)

像手表这样的时间轮模型分了时、分、秒三层的，属于分层时间轮，每一层的轮回时间都是逐层递增，例如：走完一整圈『秒轮』，需要 `60` 秒；再提升一层，走完一圈『分轮』就需要 `60*60` 秒；再往上一层就需要 `12*60*60` 秒，也就是上面所说的这个手表的时间轮最大轮回时长。

**那为什么需要时间轮呢？**

首先，我们假设要编写这样一个程序：每隔 1 秒打印一个数字，一直打印 12 小时，且这些数字预先就确定并排好了顺序，例如第一秒打印数字 100，第二秒打印数字 200 ... 那该怎么设计这个定时器呢？一个最简单粗暴的方式是创建一个容量为 43200 的数组，并把要打印的对应数字填入到数组中，然后以 1 秒为间隔，循环这个数组。

虽然上面的实现方式可以满足需求，且时间复杂度为 O(1)，但是存在两个问题：
1. 定时器数组占用的连续内存空间会随着最大定时时长的增大而增大，若需要这个定时程序运行 365 天，数组的长度就是 `86400 * 365`，假如一个数字用 4byte 来表示，就需要 120+ Mb 的**连续内存空间**，这种方式显然是不可取的；
2. 根据上一条的问题，这种方式不能实现无线循环的定时器，因为我们的**连续内存空间**是有限的；

>注意，为什么这里一直在强调是连续内存空间，是因为不管采用数组或是链表的方式，最终用于存储定时数字的内存总空间并不会减少，只不过为了能快速索引到对应的时间轮刻度，使用的数组的方式来存储数据，而为了实现定时器，耗费大块的连续内存空间是不划算的；而如果采用链表的方式，又会导致链表查询耗时增加。

而时间轮模型就很好的解决了上面的问题，它的核心思想是：把最近一轮要到期的定时事件放到最外的轮盘中，且定时器只会从最外的轮盘中触发定时消息；若最外层轮盘走完一轮后，则向上一层的轮盘取出一批定时数据；若上一层轮盘也走完一轮后，则向上上轮取一批，以此类推。这就像春运去坐高铁，安检时每次只放行 10 个人，其他已经验票通过的则在候车厅内的栏杆内排队等待，而还有一批人在候车厅外排队等待，若整个候车厅能容纳 1000 人，安检排队的栏杆区域能容纳 100 人排队，

## 添加定时消息

## 触发定时事件

## 参考

1. [Linux 内核的工作](https://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime3/).
2. [Linux 下定时器的实现方式分析](https://www.ibm.com/developerworks/cn/linux/l-cn-timers/).